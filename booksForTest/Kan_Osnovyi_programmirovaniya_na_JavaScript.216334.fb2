<?xml version="1.0" encoding="windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.2" xmlns:l="http://www.w3.org/1999/xlink">
<description>
<title-info>
<genre>computers</genre>
<author>
<first-name>Марк</first-name>
<last-name>Кан</last-name>
</author>
<book-title>Основы программирования на JavaScript</book-title>
<annotation>
<p>Курс посвящен изучению языка программирования JavaScript. JavaScript является языком сценариев (скриптов), который применяют в основном для создания на Web-страницах интерактивных элементов. Его можно использовать для построения меню, проверки правильности заполнения форм, смены изображений или для чего-то еще, что можно сделать на Web-странице.</p>
</annotation>
<date></date>
<lang>ru</lang>
</title-info>
<document-info>
<author>
<nickname>navd</nickname>
</author>
<program-used>HTMLtoFB2 v.0.5</program-used>
<date value="2012-07-15">2012-07-15</date>
<id>8DF9ADF8-C574-441A-A904-D5F8F60FC32F</id>
<version>1.01</version>
<history>
<p>Евгений Резниченко 18.10.2009</p>
<p>Sergey R 12.07.2012</p>
<p>navd: Текст отформатирован заново, это проще, чем исправлять ошибки.</p>
<p>Вообще-то такие тексты лучше делать в HTML, а не в недоделанном, примитивном и убогом FB2, в котором к тому же криво реализован тег CODE.</p>
</history>
</document-info>
</description>
<body>
<title>
<p>Марк Кан</p>
<p>Основы программирования на JavaScript</p>
</title>
<section>
<empty-line/>
<image l:href="#logo.png"/>
<empty-line/>
</section>
<section>
<title>
<p><emphasis>Лекция 1.</emphasis> Язык сценариев JavaScript</p>
</title>
<p><emphasis>Введение в язык сценариев JavaScript.</emphasis></p>
<p><strong>JavaScript</strong> является языком сценариев (скриптов), который применяют в основном для создания на Web-страницах интерактивных элементов. Его можно использовать для построения меню, проверки правильности заполнения форм, смены изображений или для чего-то еще, что можно сделать на Web-странице. Если взглянуть на Google Maps или службу GMail компании Google, то можно понять, на что способен сегодня язык <strong>JavaScript</strong>.</p>
<p>Так как <strong>JavaScript</strong> является в настоящее время единственным языком сценариев, который поддерживают все основные браузеры Web (<strong>Internet Explorer</strong>, <strong>Firefox</strong>, <strong>Netscape</strong>, <strong>Safari</strong>, <strong>Opera</strong>, <strong>Camino</strong> и т.д.), то он используется очень широко.</p>
<p>Код <strong>JavaScript</strong> обычно выполняется Web-браузером клиента, и в этом случае он называется сценарием на стороне клиента. Но код <strong>JavaScript</strong> можно выполнять также на Web-сервере для формирования документов <strong>HTML</strong>, воплощая тем самым сценарий на стороне сервера. Хотя использование <strong>JavaScript</strong> обычно ограничивается сценариями на стороне клиента, он является также очень мощным серверным языком.</p>
<p>При создании кода <strong>JavaScript</strong> требуется фактически только текстовый редактор и Web-браузер. Знание <strong>HTML</strong> и <strong>CSS</strong> будет играть определенно положительную роль, и если вы захотите использовать навыки <strong>JavaScript</strong> на Web-сайте, то понадобится также Web-сайт. Если у вас уже есть Web-сайт, то отлично! Если нет, то существует множество бесплатных серверов, которые можно использовать для размещения своих страниц.</p>
<p>Что касается текстового редактора, то в Windows имеется редактор NotePad. Хотя этого будет достаточно для редактирования <strong>JavaScript</strong>, <strong>HTML</strong> и <strong>CSS</strong>, более мощный редактор, такой, например, как EditPlus или другой, может оказаться более удобным.</p>
<p>Ну, а теперь можно перейти к созданию сценария <strong>JavaScript</strong>!</p>
<p>Прежде всего, необходимо узнать, как добавить сценарий <strong>JavaScript</strong> на страницу <strong>HTML</strong>. Это можно сделать одним из двух способов: поместить теги <strong>Script</strong> на Web-странице и расположить код <strong>JavaScript</strong> внутри этих тегов, или поместить весь код <strong>JavaScript</strong> в отдельный файл и связаться с ним с помощью тега <strong>Script</strong>.</p>
<p>Любой из этих методов вполне допустим, но они имеют разное назначение. Если имеется небольшой код, который будет использоваться только на одной странице, то размещение его между тегами <strong>Script</strong> будет хорошим решением. Если, однако, имеется большой фрагмент кода, который будет использоваться на нескольких страницах, то, наверно, лучше поместить этот код <strong>JavaScript</strong> в отдельный файл и соединиться с ним. Это делается для того, чтобы не нужно было загружать этот код всякий раз при посещении различных страниц. Код загружается один раз, и браузер сохраняет его для последующего использования. Это похоже на то, как используются каскадные таблицы стилей (<strong>CSS</strong>).</p>
<p>Ниже приведены примеры двух способов подключения кода <strong>JavaScript</strong>:</p>
<empty-line/>
<p><code>&lt;script type="text/javascript"&gt;&lt;/script&gt;</code></p>
<p><code>&lt;script type="text/javascript" src="scripts/JavaScriptFile.js"&gt;&lt;/script&gt;</code></p>
<empty-line/>
<p>В первом примере, код <strong>JavaScript</strong> помещается между символами <strong>&gt;</strong> и <strong>&lt;</strong>, прямо перед <strong>&lt;/script&gt;</strong>. Если вы совершенно не знаете, как работает Web-страница, то вот пример того, как устроена страница <strong>HTML</strong>:</p>
<empty-line/>
<p><code>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;</code></p>
<p><code>&lt;HTML&gt;</code></p>
<p><code>&lt;HEAD&gt;</code></p>
<p><code>&lt;TITLE&gt; Здесь располагается заголовок страницы &lt;/TITLE&gt;</code></p>
<p><code>&lt;META NAME="Generator" CONTENT="EditPlus"&gt;</code></p>
<p><code>&lt;META NAME="Author" CONTENT="Имя автора"&gt;</code></p>
<p><code>&lt;SCRIPT TYPE="text/javascript"&gt;</code></p>
<p><code>&lt;/SCRIPT&gt;</code></p>
<p><code>&lt;/HEAD&gt;</code></p>
<p><code>&lt;BODY&gt;</code></p>
<p><code>Здесь располагается основная содержательная часть Web-страницы (тело).</code></p>
<p><code>&lt;/BODY&gt;</code></p>
<p><code>&lt;/HTML&gt;</code></p>
<empty-line/>
<p>Сохраните этот файл где-нибудь на своем компьютере с расширением <strong>.html</strong>, так, чтобы полное имя файла было, например, таким: <strong>JavaScript_Lecture_1.html</strong>. После сохранения файла сделайте на нем двойной щелчок мышью, чтобы открыть в используемом по умолчанию браузере.</p>
<p>Почти любой язык программирования в мире имеет дело с объектами, называемыми "переменными", и <strong>JavaScript</strong> не является исключением. Переменная является просто элементом данных с присоединенным к нему именем. Она может содержать число, слово или предложение (называемые строками – <strong>String</strong>) или объект (<strong>Object</strong>), о которых будет рассказано позже. Если коду необходимо сообщить, что имеется <strong>5</strong> яблок, то можно создать переменную с именем <strong>apples</strong> и задать ей значение <strong>5</strong>. Давайте сейчас это сделаем. В <strong>JavaScript</strong> для определения переменной используется ключевое слово <strong>var</strong>. Отметим, что <strong>JavaScript</strong> различает регистр символов, поэтому <strong>var</strong> означает не то же самое, что <strong>VAR</strong> или <strong>Var</strong>.</p>
<empty-line/>
<p><code>var apples = 5;</code></p>
<empty-line/>
<p>Необходимо сделать два важных замечания в отношении этого небольшого фрагмента кода. Первое: требуется помнить о том, что <strong>JavaScript</strong> является "слабо типизированным" языком. Это означает, что при определении переменных не требуется указывать, какого они типа: будут ли они числами, строками, объектами, и т.д. Во многих других языках необходимо делать это различие.</p>
<p>Второе: обратите внимание на точку с запятой (<strong>;</strong>) в конце строки. Это говорит интерпретатору <strong>JavaScript</strong>, что вы закончили делать то, что делали в данный момент, – в нашем случае это задание значения <strong>5</strong> переменной <strong>apples</strong>. Хотя точка с запятой не является обязательной в <strong>JavaScript</strong>, лучше привыкнуть ее использовать.</p>
<p>Итак, мы определили в коде, что имеется <strong>5</strong> яблок. Что дальше? Информация о яблоках имеется в коде, но никто об этом не знает. Надо сообщить о яблоках! Одним из наиболее распространенных методов вывода простого сообщения пользователю является отправка уведомления (<strong>alert</strong>):</p>
<empty-line/>
<p><code>var apples = 5;</code></p>
<p><code>alert('Имеется' + apples + 'яблок!');</code></p>
<empty-line/>
<p>Если протестировать этот сценарий, то на экране появится окно с сообщением "<strong>Имеется 5 яблок!</strong>" Сейчас подходящее время, чтобы ввести строки (<strong>String</strong>) и так называемую конкатенацию или соединение строк. Строка является просто небольшим фрагментом текста и может содержать любой текст. В <strong>JavaScript</strong> мы сообщаем коду, что имеется строка, заключая ее в одиночные или двойные кавычки (<strong>"</strong> или <strong>'</strong>). Можно использовать любой тип кавычек. Знаки плюс (<strong>+</strong>) в примере выше сообщают коду, что мы соединяем строку с предыдущей строкой.</p>
<p>Итак мы имеем строку "<strong>Имеется</strong>" за которой следует переменная <strong>apples</strong> (равная <strong>5</strong>), за которой следует еще одна строка "<strong>яблок!</strong>". Соединим их вместе и получим "<strong>Имеется 5 яблок!</strong>". Команда <strong>alert</strong> получает то, что ей передается (то, что находится между скобок) и открывает окно с текстом.</p>
<p>Что если мы хотим предложить пользователю съесть яблоко? Можно, например, спросить, сколько яблок он хотел бы съесть:</p>
<empty-line/>
<p><code>var apples = 5;</code></p>
<p><code>alert('Имеется' + apples + 'яблок!');</code></p>
<p><code>var eat = prompt('Сколько яблок вы хотите съесть?', '1');</code></p>
<empty-line/>
<p><strong>prompt</strong> является другой встроенной функцией, аналогичной <strong>alert</strong>. Однако вместо простого вывода информации она также получает ввод от пользователя. В данном случае мы спрашиваем у пользователя, сколько яблок он хотел бы съесть. <strong>'1'</strong> в коде сообщает функции <strong>prompt</strong>, что значением по умолчанию для количества яблок будет <strong>1</strong>, так как люди обычно едят только одно яблоко за раз. Однако пользователь может изменить это значение на любое другое. Когда пользователь щелкнет на кнопке <strong>OK</strong>, переменной <strong>eat</strong> будет задано значение этого ввода. Поэтому если пользователь введет <strong>2</strong>, то <strong>eat</strong> будет равно <strong>2</strong>.</p>
<p>Поэтому, если пользователь съел <strong>2</strong> яблока, то останется <strong>3</strong>, так? Поэтому выполним несколько простых математических операций и покажем результат.</p>
<empty-line/>
<p><code>var apples = 5;</code></p>
<p><code>alert('Имеется' + apples + 'яблок!');</code></p>
<p><code>var eat = prompt('Сколько яблок вы хотите съесть?', '1');</code></p>
<p><code>apples -= parseInt(eat);</code></p>
<p><code>alert('А теперь имеется только' + apples + 'яблок!');</code></p>
<empty-line/>
<p>Здесь мы видим два новых элемента. Прежде всего, обращение к функции <strong>parseInt</strong>, которая получает строку и возвращает число. Так как для выполнения математических операций требуются числа, то это гарантирует, что мы имеем число. Если пользователь введет в поле <strong>2</strong>, то <strong>parseInt</strong> превратит это в число <strong>2</strong>.</p>
<p>Затем, оператор <strong>– =</strong>, который означает вычитание из левой части оператора значения правой части. Поэтому значение переменной <strong>eat</strong> вычитается из переменной <strong>apples</strong>. Можно также записать эту строку следующим образом:</p>
<empty-line/>
<p><code>apples = apples – parseInt(eat);</code></p>
<empty-line/>
<p>Это означает в точности то же самое и может быть немного легче для понимания. Теперь, когда известно, сколько осталось яблок, мы еще раз сообщаем пользователю эту информацию.</p>
<p>Существуют другие операторы, подобные <strong>– =</strong>, которые делают похожие вещи. Всего имеется 8 обычных арифметических операторов:</p>
<empty-line/>
<p><code>+</code></p>
<p><code>-</code></p>
<p><code>/</code></p>
<p><code>*</code></p>
<p><code>+=</code></p>
<p><code>-=</code></p>
<p><code>/=</code></p>
<p><code>*=</code></p>
<empty-line/>
<p>Вот и все для начала. В следующей лекции мы добавим в код проверку, введем операторы <strong>if</strong> и <strong>else</strong> и вкратце познакомимся с функциями.</p>
</section>
<section>
<title>
<p><emphasis>Лекция 2.</emphasis> Операторы и функции</p>
</title>
<p><emphasis>Основы проверки сценариев. Операторы if и else. Способы записи комментариев. Краткое знакомство с функциями.</emphasis></p>
<p>При тестировании сценария, написанного в предыдущей лекции, можно заметить, что результат, получаемый из <strong>prompt</strong>, требует некоторой проверки. Когда сценарий спрашивает, сколько яблок желает съесть пользователь, то пользователь может ввести число больше <strong>5</strong>, меньше <strong>0</strong> или что-то, что вообще не является числом. В каждом из таких случаев желательно информировать пользователей, что введено недопустимое значение.</p>
<p>Так как в этом сценарии имеется только <strong>5</strong> яблок, то это максимальное количество яблок, которое может получить пользователь. Поэтому начнем с проверки, что введенное число не больше <strong>5</strong>.</p>
<empty-line/>
<p><code>var apples = 5;</code></p>
<p><code>alert('Имеется' + apples + 'яблок!');</code></p>
<p><code>var eat = prompt('Сколько яблок вы хотите съесть?', '1');</code></p>
<p><code>var eaten = parseInt(eat);</code></p>
<p><code>if(eaten &gt; 5){</code></p>
<p><code>alert('Простите, но имеется только 5 яблок.' + 'Вы не можете съесть' + eaten + 'яблок!');</code></p>
<p><code>} else {</code></p>
<p><code>apples -= eaten;</code></p>
<p><code>alert('А теперь имеется только' + apples + 'яблок!');</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Основными новыми понятиями здесь являются операторы <strong>if</strong> и <strong>else</strong>. Операторы <strong>if</strong> и <strong>else</strong> достаточно легко понять. Приведенный выше код дает возможность сказать: "Если пользователь выбрал для еды более <strong>5</strong> яблок, то сообщите ему, что такого количества яблок нет. Иначе позвольте ему съесть столько яблок, сколько он попросит.".</p>
<p>Основной синтаксис оператора <strong>if / else</strong> следующий:</p>
<empty-line/>
<p><code>if(условие){</code></p>
<p><code>// код, который выполняется, когда справедливо условие if</code></p>
<p><code>} else {</code></p>
<p><code>// код, который выполняется, когда условие if ложно</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Необходимо отметить открывающую и закрывающую скобки, <strong>{</strong> и <strong>}</strong>, в приведенном выше коде. Открывающая скобка сообщает коду, где начинается блок кода, а закрывающая скобка указывает коду, где блок заканчивается. Поэтому все между <strong>{</strong> и <strong>}</strong> выполняется как часть оператора <strong>if</strong>. Необходимо отметить, что закрывающая скобка оператора <strong>if</strong> размещается непосредственно перед ключевым словом <strong>else</strong>. Оператор <strong>else</strong> имеет свой собственный набор скобок и свой собственный блок для выполнения.</p>
<p>Две косые черты <strong>//</strong> в приведенном примере говорят коду, что здесь находится комментарий. Комментарий является частью кода, который не выполняется. Они обычно используются для описания функций реального кода, чтобы не требовалось изучать код для выяснения, что он делает. Если, например, имеется очень длинный фрагмент кода, который проверяет входящие данные формы, то будет вполне разумно вставить комментарий, говорящий что-нибудь вроде "<strong>Следующий код проверяет ввод пользователя в форму</strong>". В этом случае любой, кто будет просматривать код, или сам автор кода несколько месяцев спустя после написания, сразу поймет, что этот код делает.</p>
<p>В <strong>JavaScript</strong> существует два способа записи комментариев. Первый, который мы уже видели, состоит в использовании <strong>//</strong>. Все следующее за <strong>//</strong> до конца строки считается комментарием и поэтому игнорируется при выполнении кода. Другой способ состоит в использовании комбинаций символов <strong>/*</strong> и <strong>*/</strong>, в этом случае все, что находится между ними, игнорируется.</p>
<empty-line/>
<p><code>// это однострочный комментарий</code></p>
<empty-line/>
<p><code>/*</code></p>
<p><code>если требуется более длинный комментарий, то</code></p>
<p><code>лучше использовать "блочный комментарий".</code></p>
<p><code>Этот комментарий является блочным комментарием,</code></p>
<p><code>и полностью игнорируется при выполнении кода</code></p>
<p><code>*/</code></p>
<empty-line/>
<p>Для короткого сценария комментарии не всегда нужны. Но когда код длинный, они становятся необходимостью. Программистам очень часто приходится просматривать тысячи строк кода в попытке найти место для исправления ошибки. Если код имеет хорошие комментарии, то достаточно легко почти точно определить, где находится нужный код.</p>
<p>Вернемся к нашему оператору <strong>if</strong>,</p>
<empty-line/>
<p><code>if(eaten &gt; 5){</code></p>
<p><code>alert('Простите, но имеется только 5 яблок.</code></p>
<p><code>'Вы не можете съесть' + eaten + 'яблок!');</code></p>
<p><code>} else {</code></p>
<p><code>apples -= eaten;</code></p>
<p><code>alert('А теперь имеется только' + apples + 'яблок!');</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Можно видеть, что условием является <strong>eaten &gt; 5</strong>. Знак <strong>&gt;</strong> означает "<strong>больше чем</strong>", так что это условие означает "<strong>если eaten больше 5</strong>". Аналогично, <strong>&lt;</strong> означает "<strong>меньше чем</strong>".</p>
<p>Существует два других аналогичных знака <strong>&gt;=</strong> и <strong>&lt;=</strong>, которые означают "<strong>больше чем или равно</strong>" и "<strong>меньше чем или равно</strong>" соответственно.</p>
<p>В приведенном выше коде мы сообщаем пользователю о том, что он ввел значение больше <strong>5</strong> яблок. Только если он выбрал меньше <strong>5</strong> яблок, это число вычитается из текущего количества яблок и затем пользователю сообщается, сколько яблок осталось. Однако существует еще два возможных случая. Что, если пользователь введет число меньше <strong>0</strong>? Что, если он введет значение, которое не является числом? Первый случай читатель может теперь обработать самостоятельно. Второй случай требует использования другой встроенной функции, <strong>isNaN</strong>. При попытке преобразовать что-нибудь в число с помощью функции <strong>parseInt</strong>, возвращается значение <strong>NaN</strong>, если функция не может выполнить операцию. <strong>NaN</strong> означает <strong>Not a Number</strong> (Не число). Если вызвать функцию <strong>parseInt</strong>, например, со значением <strong>apple</strong>, то будет получено значение <strong>NaN</strong>, так как слово <strong>apple</strong> не является числом.</p>
<empty-line/>
<p><code>var apples = 5;</code></p>
<p><code>alert('Имеется' + apples + 'яблок!');</code></p>
<p><code>var eat = prompt('Сколько яблок вы хотите съесть?', '1');</code></p>
<p><code>var eaten = parseInt(eat);</code></p>
<p><code>if(isNaN(eaten)){</code></p>
<p><code>alert('Вы должны ввести допустимое число яблок!');</code></p>
<p><code>} else if(eaten &gt; apples){</code></p>
<p><code>alert('Простите, но имеется только' + apples + 'яблок.</code></p>
<p><code>'Вы не можете съесть' + eaten +</code></p>
<p><code>'яблок!');</code></p>
<p><code>} else if(eaten &lt; 0){</code></p>
<p><code>alert('Простите, но вы не можете съесть</code></p>
<p><code>отрицательное количество яблок!');</code></p>
<p><code>} else {</code></p>
<p><code>apples -= eaten;</code></p>
<p><code>alert('А теперь имеется только' + apples + 'яблок!');</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Теперь все это должно быть понятно читателю. Прежде всего проверяется, что введено допустимое значение. Если значение недопустимо, выводится соответствующее сообщение. Затем проверяется, что введенное число не превышает количество существующих яблок, а затем – что это число не является отрицательным. Если все эти проверки проходят успешно, пользователь сможет съесть столько яблок, сколько захочет. В коде сделано еще одно изменение, вместо <strong>if(eaten &gt; 5)</strong> используется <strong>if(eaten &gt; apples)</strong>. Если в последующем количество имеющихся яблок <strong>var apples = 5;</strong> изменится, то это изменение пришлось бы делать только в одном месте. Старайтесь всегда использовать в коде переменные. Если значения "жестко закодированы", как было сделано ранее в коде <strong>if(eaten &gt; 5)</strong>, то очень часто при внесении изменений придется подолгу искать эти жестко закодированные значения, чтобы убедиться, что внесены все необходимые изменения.</p>
<p>Если пользователь ввел каким-либо образом недопустимое значение, то можно попросить его повторно ввести количество яблок, которое он хочет съесть. Одним из способов сделать это было бы копирование всего кода несколько раз. Однако обычно это не самое лучшее решение. Что, если пользователь вводит недопустимое значение снова и снова? Можно продолжить копирование кода, но легко видеть, что это крайне неэффективно и очень трудно поддерживать код в рабочем состоянии.</p>
<p>В этом случае лучшим решением будет использование так называемой функции. Функция содержит код, который выполняет определенную задачу. Мы уже видели использование функций <strong>alert</strong>, <strong>prompt</strong>, <strong>parseInt</strong> и <strong>isNaN</strong>, которые встроены в язык <strong>JavaScript</strong>. Преимущество использования функций состоит в том, что можно выполнять один и тот же блок кода снова и снова, не копируя этот код, Для выполнения функции необходимо написать ее имя, за которым следуют скобки <strong>()</strong>, а все значения, передаваемые в функцию, записываются между скобками.</p>
<empty-line/>
<p><code>var apples = 5;</code></p>
<p><code>function eatApples(){</code></p>
<p><code>alert('Имеется' + apples + 'яблок!');</code></p>
<p><code>var eat = prompt('Сколько яблок вы хотите съесть?', '1');</code></p>
<p><code>var eaten = parseInt(eat);</code></p>
<p><code>if(isNaN(eaten)){</code></p>
<p><code>alert('Вы должны ввести допустимое число яблок!');</code></p>
<p><code>eatApples();</code></p>
<p><code>} else if(eaten &gt; apples){</code></p>
<p><code>alert('Простите, но имеется только' + apples + 'яблок.</code></p>
<p><code>Вы не можете съесть' + eaten +</code></p>
<p><code>'яблок!');</code></p>
<p><code>eatApples();</code></p>
<p><code>} else if(eaten &lt; 0){</code></p>
<p><code>alert('Простите, но вы не можете съесть</code></p>
<p><code>отрицательное количество яблок!');</code></p>
<p><code>eatApples();</code></p>
<p><code>} else {</code></p>
<p><code>apples -= eaten;</code></p>
<p><code>alert('А теперь имеется только' + apples + 'яблок!');</code></p>
<p><code>if(apples &gt; 0){</code></p>
<p><code>if(confirm('Не хотите съесть еще яблочко?')){</code></p>
<p><code>eatApples();</code></p>
<p><code>}</code></p>
<p><code>} else {</code></p>
<p><code>alert('Яблок больше нет!');</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Здесь весь наш код записан в виде функции с именем <strong>eatApples</strong>. Можно видеть, что каждый раз, когда пользователь вводит неверное значение, снова вызывается функция <strong>eatApples();</strong>, чтобы пользователь мог ввести новое значение. Когда пользователь вводит допустимое значение, то он либо может еще есть яблоки, либо, если все яблоки закончились, он получит соответствующее сообщение. Здесь используется также одна новая функция, <strong>confirm</strong>. Функция <strong>confirm</strong> просто выводит пользователю приглашение <strong>OK or Cancel</strong> ("Да или Отмена"). Если пользователь нажмет кнопку "<strong>OK</strong>", то функция возвращает значение <strong>true</strong> (да). Если пользователь нажмет кнопку <strong>Cancel</strong> или просто закроет окно, то функция <strong>confirm</strong> возвращает значение <strong>false</strong> (нет). Поэтому в нашем примере функция <strong>eatApples</strong> вызывается снова только в том случае, когда пользователь щелкнет на кнопке <strong>OK</strong>.</p>
<p>В конце этой лекции будет рассмотрена область действия переменной. Как можно видеть, в последнем примере переменная <strong>apples</strong> находится вне функции <strong>eatApples</strong>. Это делает переменную <strong>apples</strong> "глобальной переменной", т.е. она будет доступна из любой функции. Переменная <strong>eat</strong>, с другой стороны, является локальной переменной и существует только внутри функции <strong>eatApples</strong>. Кроме того, каждый раз при вызове функции <strong>eatApples</strong> переменная <strong>eat</strong> не будет существовать, пока не будет снова определена функцией <strong>prompt</strong>.</p>
<p>Чтобы увидеть эту концепцию в действии, напишем две простые функции счета:</p>
<empty-line/>
<p><code>function counting1(){</code></p>
<p><code>var count = 0;</code></p>
<p><code>count++;</code></p>
<p><code>alert(count);</code></p>
<p><code>}</code></p>
<p><code>var count = 0;</code></p>
<p><code>function counting2(){</code></p>
<p><code>count++;</code></p>
<p><code>alert(count);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Если запустить этот пример в браузере и щелкнуть на каждой кнопке несколько раз, то можно заметить, что <strong>counting1</strong> всегда выдает одно и то же значение, <strong>1</strong>. <strong>counting2</strong>, с другой стороны, выдает увеличивающееся число. Почему это происходит? Посмотрим просто сначала на <strong>counting1</strong>. Можно видеть, что каждый раз при выполнении <strong>counting1</strong> прежде всего создается переменная <strong>count</strong> и ее значение задается равным <strong>0</strong>. В следующей строке переменная <strong>count</strong> увеличивается на <strong>1</strong>.</p>
<p>Оператор <strong>++</strong> пока еще не встречался. <strong>count++</strong> просто увеличивает <strong>count</strong> на <strong>1</strong>. Другими словами, это в точности то же самое, что написать <strong>count += 1</strong> или <strong>count = count + 1</strong>. Поскольку увеличение на <strong>1</strong> является в программировании очень распространенным действием, то для него существует специальный оператор. Аналогично оператор <strong>– -</strong> вычитает <strong>1</strong> из переменной: <strong>count--</strong>.</p>
<p>Каждый раз, когда функция <strong>counting1</strong> выполняет <strong>alert(count)</strong>, она сообщает значение новой переменной <strong>count</strong> , которое только что было определено как <strong>0+1</strong>.</p>
<p>Теперь посмотрим на <strong>counting2</strong>. Можно видеть, что переменная <strong>count</strong> в этом случае находится вне функции. Даже до вызова этой функции значение <strong>count</strong> задано как <strong>0</strong>. При вызове <strong>counting2</strong> прежде всего происходит увеличение переменной <strong>count</strong> на <strong>1</strong>. Так как мы не восстанавливаем значение <strong>count</strong> в <strong>0</strong>, как в случае <strong>counting1</strong>, то переменная <strong>count</strong> продолжает сохранять свое значение, и все происходит, как и предполагалось.</p>
<p>Теперь читатель получил общее понимание некоторых фундаментальных понятий программирования и <strong>JavaScript</strong>, в частности. В следующей лекции будут рассмотрены циклы и формы.</p>
</section>
<section>
<title>
<p><emphasis>Лекция 3.</emphasis> Формы и циклы</p>
</title>
<p><emphasis>Основы работы с полями форм и с функциями циклов.</emphasis></p>
<p>В предыдущей лекции были рассмотрены операторы <strong>if</strong>/<strong>else</strong>, основы проверки и функций. Если в ходе дальнейшего чтения возникнут какие-то вопросы, то имеет смысл еще раз прочитать предыдущую лекцию.</p>
<p>Мы знаем теперь, как проверять данные, но при создании кода <strong>JavaScript</strong> обычно требуется проверять не оставшееся количество воображаемых яблок. Одной из наиболее общих областей применения <strong>JavaScript</strong> являются поля формы. Предположим, например, что имеется простая контактная форма. Иногда требуется убедиться, что пользователь ввел в форму свое имя или что он выбрал как минимум одну радио-кнопку для вопроса. Вот пример такой формы:</p>
<empty-line/>
<p><code>Имя: Ваш любимый цвет: Синий Желтый</code></p>
<p><code>Красный Черный</code></p>
<p><code>Зеленый Другой</code></p>
<p><code>Фамилия:</code></p>
<p><code>Адрес Email:</code></p>
<empty-line/>
<p><code>Отправить форму Очистить форму Зафиксировать форму на месте</code></p>
<empty-line/>
<p>Ниже представлен код этой формы. Он приведен только для иллюстрации.</p>
<empty-line/>
<p><code>&lt;form name="tutform" onsubmit="return noform();" class="codesnip"</code></p>
<p><code>style="background-color:#FFF;z-index:10;"&gt;</code></p>
<p><code>&lt;table width="100%"&gt;</code></p>
<p><code>&lt;tr&gt;</code></p>
<p><code>&lt;td&gt;Имя:&lt;/td&gt;</code></p>
<p><code>&lt;td&gt;&lt;input name="firstname"&gt;&lt;/td&gt;</code></p>
<p><code>&lt;td&gt;Ваш любимый цвет:&lt;/td&gt;</code></p>
<p><code>&lt;td rowspan="3" valign="top"&gt;</code></p>
<p><code>&lt;input type="radio" name="color" value="blue"&gt;Синий&lt;br /&gt;</code></p>
<p><code>&lt;input type="radio" name="color" value="red"&gt;Красный&lt;br /&gt;</code></p>
<p><code>&lt;input type="radio" name="color" value="green"&gt;Зеленый</code></p>
<p><code>&lt;/td&gt;</code></p>
<p><code>&lt;td rowspan="3" valign="top"&gt;</code></p>
<p><code>&lt;input type="radio" name="color" value="yellow"&gt;Желтый&lt;br /&gt;</code></p>
<p><code>&lt;input type="radio" name="color" value="black"&gt;Черный&lt;br /&gt;</code></p>
<p><code>&lt;input type="radio" name="color" value="other"&gt;Другой</code></p>
<p><code>&lt;/td&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<p><code>&lt;tr&gt;</code></p>
<p><code>&lt;td&gt;Фамилия:&lt;/td&gt;</code></p>
<p><code>&lt;td&gt;&lt;input name="lastname"&gt;&lt;/td&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<p><code>&lt;tr&gt;</code></p>
<p><code>&lt;td&gt;Адрес Email:&lt;/td&gt;</code></p>
<p><code>&lt;td&gt;&lt;input name="email"&gt;&lt;/td&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<p><code>&lt;tr&gt;</code></p>
<p><code>&lt;td colspan="2"&gt;&lt;input type="submit" value="Отправить форму"&gt;</code></p>
<p><code>&lt;input type="reset" value="Очистить форму"&gt;&lt;/td&gt;</code></p>
<p><code>&lt;td colspan="3" align="right"&gt;&lt;button id="lockbutton"</code></p>
<p><code>onclick="swapLock();return false;"&gt;Зафиксировать форму на месте&lt;/button&gt;&lt;/td&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<p><code>&lt;/table&gt;</code></p>
<p><code>&lt;/form&gt;</code></p>
<empty-line/>
<p>Прежде всего необходимо узнать, как создать объект <strong>JavaScript</strong>, который ссылается на форму. Любую форму на странице можно указать с помощью конструкции <strong>document.forms</strong>. Если имеется форма с именем <strong>tutform</strong>, то к ней можно обратиться следующим образом: <strong>document.forms.tutform</strong>.</p>
<p>На любые элементы внутри формы (поля ввода, поля выбора, флажки и т.д) можно ссылаться с помощью конструкции <strong>elements</strong>: <strong>document.forms.ИмяФормы.elements</strong>. Если на форме имеется поле ввода с именем <strong>firstname</strong>, то значение этого поля можно вывести следующим образом:</p>
<empty-line/>
<p><code>alert('Имя:' + document.forms.tutform.elements.firstname.value);</code></p>
<empty-line/>
<p>Если щелкнуть на этой кнопке, а затем отправить учебную форму, то появится уведомление с тем значением, которое было введено в поле <strong>Имя</strong>. Как это происходит? Когда форма посылается на сервер, Web-браузер ищет код <strong>onsubmit</strong>. Если этот код существует, то форма выполняет его перед отправкой:</p>
<empty-line/>
<p><code>&lt;SCRIPT TYPE="text/javascript"&gt;</code></p>
<p><code>function validateForm(){</code></p>
<p><code>// код проверки формы находится здесь</code></p>
<p><code>}</code></p>
<p><code>&lt;/SCRIPT&gt;</code></p>
<p><code>&lt;FORM ONSUBMIT="return validateForm();"&gt;</code></p>
<p><code>&lt;!-- элементы формы находятся здесь --&gt;</code></p>
<p><code>&lt;/FORM&gt;</code></p>
<empty-line/>
<p>Теперь, зная, как получить доступ к форме и элементам на этой форме, выполним некоторые основные проверки. Распространенной задачей является проверка, что именно пользователь ввел в поле ввода. Например, надо проверить, что пользователь ввел свое имя.</p>
<p>Как видно из предыдущего фрагмента кода, свойство "<strong>.value</strong>" объекта формы можно использовать для получения его значения. Это работает для объектов формы любого типа. Попробуем теперь проверить, что пользователь ввел на форме свои имя и фамилию:</p>
<empty-line/>
<p><code>function validateForm(){</code></p>
<p><code>var form_object = document.forms.tutform;</code></p>
<p><code>if(form_object.elements.firstname.value == ''){</code></p>
<p><code>alert('Вы должны ввести свое имя!');</code></p>
<p><code>return false;</code></p>
<p><code>} else if(form_object.elements.lastname.value == ''){</code></p>
<p><code>alert('Вы должны ввести свою фамилию!');</code></p>
<p><code>return false;</code></p>
<p><code>}</code></p>
<p><code>return true;</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Важными моментами, которые необходимо отметить в этой функции, являются строки <strong>return false</strong>; и <strong>return true</strong>;. Если функция проверки возвращает значение <strong>true</strong>, то форма будет отправлена как обычно. Если, однако, функция вернет значение <strong>false</strong>, то форма отправлена не будет. Необходимо сообщить пользователю, почему форма не была отправлена, поэтому в функцию вставлены уведомления (<strong>alert</strong>).</p>
<p>Другим важным полем для проверки в демонстрационной форме будет набор радио-кнопок "<strong>Любимый цвет</strong>". Если щелкнуть несколько раз на этих кнопках, то можно видеть, что в данный момент времени может быть выбрана только одна из них. Но желательно знать, что пользователь выбрал хотя бы одну из этих кнопок.</p>
<p>Радио-кнопки и флажки на форме представляют специальную ситуацию. Часто имеется несколько радио-кнопок с одним и тем же именем, что почти всегда исключено для полей ввода, полей выбора и т.д.:</p>
<empty-line/>
<p><code>&lt;input type="radio" name="color" value="blue"&gt;Синий</code></p>
<p><code>&lt;input type="radio" name="color" value="red"&gt;Красный</code></p>
<p><code>&lt;input type="radio" name="color" value="green"&gt;Зеленый</code></p>
<empty-line/>
<p>В связи с этим существует способ доступа ко всем радио-кнопкам с одним именем. Значение <strong>document.forms.имяФормы.elements.имяРадиокнопок</strong> будет содержать список со всеми радио-кнопками. Так как необходимо проверить, что хотя бы одна радио-кнопка отмечена, то потребуется просмотреть все эти радио-кнопки. Если хотя бы одна из них отмечена, функция проверки должна вернуть <strong>true</strong>. Поэтому функция выглядит теперь следующим образом:</p>
<empty-line/>
<p><code>function validateForm(){</code></p>
<p><code>var radios = document.forms.tutform.elements.color;</code></p>
<p><code>for(var i=0; i&lt;radios.length; i++){</code></p>
<p><code>if(radios[i].checked) return true;</code></p>
<p><code>}</code></p>
<p><code>alert('Вы должны выбрать цвет!');</code></p>
<p><code>return false;</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Новым элементом в этом коде является так называемый цикл <strong>for</strong>. Он выглядит немного более сложно, чем есть в действительности, поэтому разберем его составные элементы:</p>
<empty-line/>
<p><code>for(var i=0; i&lt;radios.length; i++){</code></p>
<empty-line/>
<p>Внутри скобок имеется три значения, разделенные точкой с запятой. Этими значениями, по отдельности, являются:</p>
<empty-line/>
<p><code>var i=0</code></p>
<p><code>i&lt;radios.length</code></p>
<p><code>i++</code></p>
<empty-line/>
<p>Первое значение является просто заданием значения переменной. Это должно быть теперь понятно без проблем. Второе значение является условием проверки. Цикл <strong>for</strong> будет выполняться, пока это условие проверки возвращет <strong>true</strong>. Как только оно вернет <strong>false</strong>, цикл <strong>for</strong> остановится и выполнение кода продолжится со следующей строки. Поэтому условие <strong>i&lt;radios.length</strong> говорит, что цикл <strong>for</strong> должен выполняться, пока переменная <strong>i</strong> меньше числа имеющихся радио-кнопок.</p>
<p>"<strong>length</strong>" в данном случае является свойством массива. Мы пока еще не встречались с массивами, но, упрощая, можно сказать, что <strong>radios.length</strong> возвращает просто число элементов в <strong>radios</strong>, которое в данном случае равно <strong>6</strong>, так как имеется только <strong>6</strong> радио-кнопок. Последнее выражение цикла <strong>for</strong>, <strong>i++</strong> , является кодом, который должен выполняться после каждого шага цикла.</p>
<p>Говоря более простым языком, цикл <strong>for</strong> делает следующее:</p>
<p><strong>1</strong> задает <strong>i</strong> равным <strong>0</strong>;</p>
<p><strong>2</strong> проверяет, что <strong>i</strong> меньше <strong>radios.length</strong>, которое равно <strong>6</strong>;</p>
<p><strong>3</strong> если это справедливо (<strong>true</strong>), выполняет код в цикле <strong>for</strong>;</p>
<p><strong>4</strong> после выполнения кода в цикле <strong>for</strong> добавляет <strong>1</strong> к переменной <strong>i</strong>;</p>
<p><strong>5</strong> переходит к шагу 2, пока выполняется условие <strong>i&lt;radios.length</strong> . Это условие не выполнится после шестого выполнения цикла, когда <strong>i=6</strong>.</p>
<p>Существует другой тип цикла, который сейчас будет рассмотрен, – так называемый цикл <strong>while</strong>. Следующий код делает то же самое, что и предыдущий цикл:</p>
<empty-line/>
<p><code>var i=0;</code></p>
<p><code>while(i&lt;radios.length){</code></p>
<p><code>if(radios[i].checked) return true;</code></p>
<p><code>i++;</code></p>
<p><code>}</code></p>
<p><code>alert('Вы должны выбрать цвет!');</code></p>
<p><code>return false;</code></p>
<empty-line/>
<p>Можно видеть, что здесь в цикле <strong>while</strong> присутствуют точно те же <strong>3</strong> фрагмента кода, которые имелись в цикле <strong>for</strong>: "<strong>var i=0</strong>", "<strong>i&lt;radios.length</strong>" и "<strong>i++</strong>". Единственное отличие состоит в их размещении. В цикле <strong>while</strong> только проверка</p>
<empty-line/>
<p><code>i&lt;radios.length</code></p>
<empty-line/>
<p>чем-то отличается от того, что было написано раньше. Эта проверка происходит в скобках сразу после <strong>while</strong>. Переменные инициализируются перед циклом <strong>while</strong>, а увеличение <strong>i</strong>, <strong>i++</strong>, происходит внутри цикла.</p>
<p>В этих циклах осталось объяснить еще одну вещь: <strong>if(radios[i].checked)</strong>. Переменная <strong>radios</strong> содержит массив радио-кнопок с именем <strong>color</strong>. Массивы будут рассмотрены в следующей лекции, а здесь дадим упрощенное объяснение: <strong>radios[0]</strong> возвращает первую радио-кнопку, <strong>radios[1]</strong> возвращает вторую, <strong>radios[2]</strong> – третью, и т.д. до <strong>radios[5]</strong>, который возвращает шестую кнопку. Если кнопок будет больше, например, <strong>100</strong>, то <strong>radios[99]</strong> будет обращаться к <strong>100</strong>– ой радио-кнопке.</p>
<p>Все эти числа могут показаться странными. Почему <strong>radios[5]</strong> обращается к шестой радио-кнопке? В <strong>JavaScript</strong>, как и во многих других языках программирования, многие вещи начинаются с числа <strong>0</strong>, а не с <strong>1</strong>. Это просто один из таких случаев, но это встретится еще не раз. Поэтому <strong>0</strong> является в действительности первым элементом, <strong>1</strong> – вторым, и т.д.</p>
<p>В форме осталось проверить еще ввод адреса e-mail. Это в действительности достаточно сложное для проверки поле, и правильная ее реализация выходит за рамки того, что изучается в этой лекции, но можно выполнить некоторую базовую проверку. Что нужно сделать? Мы знаем, что любой адрес e-mail должен содержать один и только один символ <strong>@</strong>. Он должен также содержать по крайней мере одну точку после символа <strong>@</strong> (точка отделяет имя домена от домена верхнего уровня, например, "<strong>intuit.ru</strong> ").</p>
<empty-line/>
<p><code>function validateForm(){</code></p>
<p><code>var email = document.forms.tutform.elements.email.value;</code></p>
<p><code>if(email.indexOf('@')&lt;0){</code></p>
<p><code>alert('В адресе e-mail должен присутствовать символ @');</code></p>
<p><code>return false;</code></p>
<p><code>} else if(email.indexOf('@') != email.lastIndexOf('@')){</code></p>
<p><code>alert('В адресе e-mail не может быть больше одного символа @');</code></p>
<p><code>return false;</code></p>
<p><code>} else if(email.indexOf('.')&lt;0){</code></p>
<p><code>alert('В адресе e-mail должна присутствовать хотя бы одна точка.');</code></p>
<p><code>return false;</code></p>
<p><code>} else if(email.lastIndexOf('.')&lt;email.indexOf('@')){</code></p>
<p><code>alert('В адресе e-mail должна присутствовать хотя бы одна точка после символа @');</code></p>
<p><code>return false;</code></p>
<p><code>}</code></p>
<p><code>return true;</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Здесь имеются две новые сходные функции, которые требуют пояснения. Функция <strong>indexOf</strong> возвращает число, определяющее позицию одной строки в другой строке. <strong>'abcdef'.indexOf('a')</strong> вернет <strong>0</strong> (здесь <strong>0</strong> снова означает первую позицию). <strong>'abcdef'.indexOf('cdef')</strong> вернет <strong>2</strong>, а <strong>'abcdef'.indexOf('aaa')</strong> вернет <strong>– 1</strong>. <strong>– 1</strong> означает, что строка не найдена. Во многих случаях возвращается <strong>– 1</strong>, когда функция не может получить результат.</p>
<p>Аналогично, функция <strong>lastIndexOf</strong> возвращает позицию последнего вхождения одной строки в другую. <strong>'abcba'.lastIndexOf('a')</strong> вернет <strong>4</strong>, в то время как <strong>'abcba'.indexOf('a')</strong> вернет <strong>0</strong>.</p>
<p>Поэтому в нашем коде первый оператор <strong>if</strong> проверяет, что в адресе e-mail имеется хотя бы один символ <strong>'@'</strong>. Если такого символа нет, то <strong>email.indexOf('@')</strong> вернет <strong>– 1</strong> и оператор <strong>if</strong> вернет <strong>false</strong>.</p>
<p>Следующий оператор соединяет <strong>indexOf</strong> и <strong>lastIndexOf</strong>. Если в адресе e-mail имеется более одного символа <strong>@</strong>, то две эти функции вернут различные значения, как в приведенном выше примере с <strong>'abcba'</strong>. Если имеется только один символ <strong>@</strong>, то эти функции вернут одно и то же значение. Поэтому мы проверяем эти значения на неравенство.</p>
<p>Третий оператор по сути идентичен первому, только он проверяет <strong>'.'</strong>, а не <strong>'@'</strong>.</p>
<p>Наконец, четвертый оператор <strong>if</strong> проверяет, что в адресе e-mail имеется как минимум одна точка после символа <strong>@</strong>.</p>
<p>Недостаток этого метода состоит в том, что простая строка "<strong>@.</strong>" пройдет проверку. Должно быть очевидно, что она не является допустимым адресом e-mail. Существует другой метод для проверки адреса e-mail и для проверки множества других вещей. Это делается с помощью так называемых "регулярных выражений". Хотя регулярные выражения здесь рассматриваться не будут, ниже приведен пример проверки адреса e-mail, который остается читателю для анализа в качестве упражнения.</p>
<empty-line/>
<p><code>function validateForm(){</code></p>
<p><code>var email = document.forms.tutform.elements.email.value;</code></p>
<p><code>if(!(/^[a-zA-Z][\w\.-]*[a-zA-Z0-9]@[a-zA-Z0-9][\w\.-]*[a-zA-Z0-9]\.</code></p>
<p><code>[a-zA-Z][a-zA-Z\.]*[a-zA-Z]$/.test(email))){</code></p>
<p><code>alert('Пожалуйста, введите допустимый адрес e-mail');</code></p>
<p><code>return false;</code></p>
<p><code>}</code></p>
<p><code>return true;</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Как можно видеть, использование регулярного выражения приводит к более короткому (и более надежному) коду проверки, но он является и существенно более сложным!</p>
<empty-line/>
<p>С помощью примеров этой лекции теперь можно создать одну функцию для проверки всей формы:</p>
<empty-line/>
<p><code>function tut7(){</code></p>
<p><code>var form_object = document.forms.tutform;</code></p>
<p><code>var radios = document.forms.tutform.elements.color;</code></p>
<p><code>var email = document.forms.tutform.elements.email.value;</code></p>
<p><code>if(form_object.elements.firstname.value == "){</code></p>
<p><code>alert('Вы должны ввести свое имя!');</code></p>
<p><code>return false();</code></p>
<p><code>} else if(form_object.elements.lastname.value == "){</code></p>
<p><code>alert('Вы должны ввести свою фамилию!');</code></p>
<p><code>return false();</code></p>
<p><code>} else if(email.indexOf('@')&lt;0){</code></p>
<p><code>alert('В адресе e-mail должен быть символ @');</code></p>
<p><code>return false();</code></p>
<p><code>} else if(email.indexOf('@') != email.lastIndexOf('@')){</code></p>
<p><code>alert('В адресе e-mail не может быть более одного символа @');</code></p>
<p><code>return false();</code></p>
<p><code>} else if(email.indexOf('.')&lt;0){</code></p>
<p><code>alert('В адресе e-mail должна быть как минимум одна точка');</code></p>
<p><code>return false();</code></p>
<p><code>} else if(email.lastIndexOf('.')&lt;email.indexOf('@')){</code></p>
<p><code>alert('В адресе e-mail должна быть как минимум одна точка после символа @');</code></p>
<p><code>return false();</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;radios.length; i++){</code></p>
<p><code>if(radios[i].checked) return true();</code></p>
<p><code>}</code></p>
<p><code>alert('Необходимо выбрать цвет!');</code></p>
<empty-line/>
<p><code>return false;</code></p>
<p><code>}</code></p>
<empty-line/>
</section>
<section>
<title>
<p><emphasis>Лекция 4.</emphasis> Функции и концепция объектов</p>
</title>
<p><emphasis>В этой лекции будут полностью рассмотрены функции и представлена концепция объектов в <strong>JavaScript</strong>.</emphasis></p>
<p>В предыдущей лекции мы рассмотрели основы работы с полями форм и немного познакомились с функциями. Если какие-то из этих понятий вызывают затруднения, то желательно еще раз прочитать последнюю лекцию.</p>
<p>Как мы уже знаем, функции в <strong>JavaScript</strong> используются для многократного выполнения одной и той же задачи. До сих пор функции всегда вызывались вручную с помощью скобок: <strong>myFunction()</strong>. Что, если потребуется вызвать функцию, когда пользователь выполняет определенную задачу? В <strong>JavaScript</strong> можно соединить функцию практически с любым событием, которое может порождать пользователь. Давайте посмотрим это в действии и напишем функцию, которая подсчитывает, сколько раз пользователь щелкнул на странице.</p>
<empty-line/>
<p><code>&lt;script type="text/javascript"&gt;</code></p>
<p><code>var clickCount = 0;</code></p>
<p><code>function documentClick(){</code></p>
<p><code>document.getElementById('clicked').value = ++clickCount;</code></p>
<p><code>}</code></p>
<p><code>document.onclick = documentClick;</code></p>
<p><code>&lt;/script&gt;</code></p>
<p><code>Вы щелкнули на этой странице &lt;input id="clicked" size="3" onfocus="this.blur();" value="0"&gt; раз.</code></p>
<p><code>Вы щелкнули на этой странице раз.</code></p>
<empty-line/>
<p>В предыдущей лекции оператор <strong>++</strong> был применен только после переменной, как в случае <strong>clickCount++</strong>. Однако в данном примере оператор <strong>++</strong> используется перед переменной. В первом примере <strong>clickCount++</strong>, единица добавляется к переменной <strong>clickCount</strong> после чтения ее значения. В случае <strong>++clickCount</strong> единица добавляется к переменной <strong>clickCount</strong> перед чтением ее значения. Так как в этом примере переменной <strong>clickCount</strong> в начале присваивается значение <strong>0</strong>, то единицу к ней необходимо добавлять до задания значения поля ввода, поэтому использована запись <strong>++clickCount</strong>.</p>
<p>Предыдущий пример может показаться достаточно знакомым. Так же, как и раньше, определяется переменная и функция. Изменение состоит в том, что вместо вызова функции <strong>documentClick()</strong> код содержит указание, что функция должна выполняться всякий раз, когда пользователь щелкает на документе. <strong>document.onclick</strong> связывает функцию с событием документа <strong>onclick</strong> ("при щелчке").</p>
<p>Существует множество событий подобных <strong>onclick</strong>. Мы познакомимся с некоторыми из них, но наиболее распространенными являются: <strong>onclick</strong>, <strong>onload</strong>, <strong>onblur</strong>, <strong>onfocus</strong>, <strong>onchange</strong>, <strong>onmouseover</strong>, <strong>onmouseout</strong> и <strong>onmousemove</strong>. Функцию можно связать с событиями любого объекта, такого, как изображение или поле ввода, а не только документа. Например, события <strong>onmouseover</strong> и <strong>onmouseout</strong> используются обычно с изображениями для создания эффекта изменения.</p>
<p>Можно также заметить, что ссылка на поле ввода делается другим образом. Ранее говорилось, что для указания поля необходимо использовать <strong>document.forms.имяФормы.elements.имяПоляВвода</strong>. Хотя этот способ прекрасно работает, это не всегда необходимо. В данном примере поле ввода действует просто как счетчик. Оно не находится внутри формы, и нам это и не нужно. Поэтому мы задаем для поля некоторый <strong>ID</strong> (идентификатор): <strong>id="clicked"</strong>. <strong>ID</strong> можно использовать для ссылки на любой объект на странице. <strong>ID</strong> должен быть уникальным на странице, поэтому если имеется <strong>5</strong> полей ввода с <strong>ID</strong>, то все <strong>ID</strong> должны быть различны, даже если они только имеют вид <strong>"input1"--&gt;"input5"</strong>.</p>
<p>Поскольку это поле ввода используется как счетчик, то нежелательно, чтобы пользователи щелкали на нем и изменяли его значение. Здесь на помощь приходит другое связывание, <strong>onfocus</strong>, которое срабатывает, когда курсор перемещается на объект. Поэтому при щелчке на поле ввода или при перемещении на поле ввода с помощью клавиши <strong>Tab</strong> вызывается <strong>onfocus</strong>.</p>
<p>Событие <strong>onfocus</strong> имеет очень короткий код, но он также очень важен. В нем появляется ключевое слово <strong>this</strong>, которое важно понимать в <strong>JavaScript</strong>. Ключевое слово <strong>this</strong> указывает на тот объект, на котором выполняется код. В данном примере <strong>this</strong> указывает на поле ввода. Выражение <strong>this.blur()</strong> "размывает" поле ввода, другими словами, заставляет его терять фокус ввода. Так как это происходит, как только пользователь активизирует поле ввода, то это делает "невозможным" изменение данных.</p>
<p>Если указатель <strong>this</strong> используется в функции, то он указывает на саму функцию. Если <strong>this</strong> используется в коде <strong>JavaScript</strong> вне функции, то он указывает на объект окна. Наиболее часто <strong>this</strong> используется для изменения свойства текущего объекта, как в примере выше, или для передачи текущего объекта функции.</p>
<p>Давайте посмотрим на другой пример:</p>
<empty-line/>
<p><code>&lt;script type="text/javascript"&gt;</code></p>
<p><code>function showValue(obj){</code></p>
<p><code>alert('You Clicked On' + obj.value);</code></p>
<p><code>}</code></p>
<p><code>&lt;/script&gt;</code></p>
<empty-line/>
<p><code>&lt;input type="radio" name="fruit" onclick="showValue(this);" value="Яблоко" &gt; Яблоко</code></p>
<p><code>&lt;input type="radio" name="fruit" onclick="showValue(this);" value="Апельсин" &gt; Апельсин</code></p>
<p><code>&lt;input type="radio" name="fruit" onclick="showValue(this);" value="Груша" &gt; Груша</code></p>
<p><code>&lt;input type="radio" name="fruit" onclick="showValue(this);" value="Банан"&gt; Банан</code></p>
<empty-line/>
<p><code>Яблоко Апельсин Груша Банан</code></p>
<empty-line/>
<p>Можно видеть, что событие <strong>onclick</strong> для каждой из этих радио-кнопок одинаково. Однако, если щелкнуть на каждой из них, то будут получены разные сообщения. Это связано с использованием <strong>this</strong>. Так как <strong>this</strong> указывает на каждую отдельную радио-кнопку, то каждая радио-кнопка передается в функцию <strong>showValue</strong> по отдельности.</p>
<p>Вернемся к функциям и рассмотрим передачу функции аргументов. В предыдущем примере <strong>obj</strong> является аргументом. Предполагается, что <strong>obj</strong> содержит указатель на поле ввода, на котором был произведен щелчок. В функцию можно передавать любое количество аргументов. Если потребуется <strong>10</strong> аргументов, то функция будет выглядеть следующим образом:</p>
<empty-line/>
<p><code>function myFunction(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10){</code></p>
<p><code>// здесь располагается код</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Во многих случаях может понадобиться функция, которой требуется определенное количество аргументов, но не всегда требуются все. В <strong>JavaScript</strong> не нужно передавать все <strong>10</strong> аргументов в функцию, которая объявлена с <strong>10</strong> аргументами. Если передать только первые <strong>3</strong>, то функция будет иметь только <strong>3</strong> определенных аргумента. Это необходимо учитывать при написании функций. Например, можно написать функцию, которой всегда требуются <strong>3</strong> первых аргумента, но следующие <strong>7</strong> являются необязательными:</p>
<empty-line/>
<p><code>function myFunction(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10){</code></p>
<p><code>// код с arg1</code></p>
<p><code>// код с arg2</code></p>
<p><code>// код с arg3</code></p>
<p><code>if(arg4){</code></p>
<p><code>// код с arg4</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>if(arg5 &amp;&amp; arg6 &amp;&amp; arg7){</code></p>
<p><code>// код с arg5, arg6 и arg7</code></p>
<p><code>if(arg8){</code></p>
<p><code>// код с arg8</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>if(arg9 || arg10){</code></p>
<p><code>// код с arg9 или arg10</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Можно видеть, что в коде выполняется простая проверка <strong>if(arg)</strong>. Если аргумент не передается в функцию, то при попытке использовать этот аргумент будет получено значение <strong>undefined</strong>. При использовании <strong>undefined</strong> в качестве логического (булевого) значения (<strong>true / false</strong>), как в операторах <strong>if</strong>, оно воспринимается как <strong>false</strong>.</p>
<p>Поэтому, если <strong>arg4</strong> не был передан в приведенном выше примере, то он является <strong>undefined</strong> и тело оператора <strong>if</strong> не выполняется.</p>
<p>Как быть, когда трудно определить, сколько потребуется аргументов? Можно иметь функцию, которая получает от <strong>1</strong> до <strong>n</strong> аргументов и выполняет с каждым из них одну и ту же задачу. На этот случай <strong>JavaScript</strong> имеет в каждой функции объект <strong>arguments</strong>. Объект <strong>arguments</strong> содержит все аргументы функции:</p>
<empty-line/>
<p><code>function myFunction(){</code></p>
<p><code>for(var i=0; i&lt;arguments.length; i++){</code></p>
<p><code>alert(arguments[i].value);</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Этот код сообщит значение всех переданных ему объектов. Если передать <strong>100</strong> объектов, то будет получено <strong>100</strong> сообщений. Более полезной функцией было бы, возможно, скрытие/вывод всех переданных функции объектов.</p>
<p>Один из наиболее интересных аспектов <strong>JavaScript</strong> – идея о том, что функции являются объектами и могут передаваться как поле ввода, изображение или что-то еще, что может быть. Посмотрите, например, следующий код:</p>
<empty-line/>
<p><code>&lt;script type="text/javascript"&gt;</code></p>
<p><code>function multiply(){</code></p>
<p><code>var out=1;</code></p>
<p><code>for(var i=0; i&lt;arguments.length; i++){</code></p>
<p><code>out *= arguments[i];</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>return out;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function add(){</code></p>
<p><code>var out=0;</code></p>
<p><code>for(var i=0; i&lt;arguments.length; i++){</code></p>
<p><code>out += arguments[i];</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>return out;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function doAction(action){</code></p>
<p><code>alert(action(1, 2, 3, 4, 5));</code></p>
<p><code>}</code></p>
<p><code>&lt;/script&gt;</code></p>
<empty-line/>
<p><code>&lt;button onclick="doAction(multiply)"&gt;Test Multiply&lt;/button&gt;</code></p>
<p><code>&lt;button onclick="doAction(add)" &gt;Test Add&lt;/button&gt;</code></p>
<empty-line/>
<p><code>Test Multiply Test Add</code></p>
<empty-line/>
<p>В этом небольшом фрагменте кода происходит очень многое. Вначале просто определяют две функции: <strong>multiply</strong> и <strong>add</strong>. Функция <strong>multiply</strong> просто перемножает все переданные ей числа. Аналогично, функция <strong>add</strong> складывает все переданные ей числа. Тонкости начинаются при использовании действий <strong>onclick</strong> двух созданных кнопок. Можно видеть, что при щелчке на любой из двух кнопок в функцию <strong>doAction</strong> передается объект. Ранее мы всегда передавали переменные или объекты <strong>HTML</strong> (такие, как поля ввода в предыдущем примере). В этом примере передаются функции. Функции можно передавать таким же способом, как и любой другой объект, и когда они передаются, их можно вызывать таким же способом, как и любую другую функцию. Изменяется только ее имя.</p>
<p>Таким образом функция <strong>doAction</strong> получает другую функцию в качестве аргумента! Если передается функция <strong>multiply</strong>, то функция <strong>doAction</strong> передает ей значения от <strong>1</strong> до <strong>5</strong>, и мы получаем в результате <strong>120</strong>. Если в <strong>doAction</strong> передается функция <strong>add</strong>, то ей также передаются значения от <strong>1</strong> до <strong>5</strong>, и в результате мы получаем значение <strong>15</strong>.</p>
<p>Это в действительности одно из наиболее мощных свойств <strong>JavaScript</strong>, и оно будет более подробно рассмотрено в следующих лекциях. Пока достаточно понять общий принцип.</p>
<p>Другим важным свойством функций является возможность вложения их друг в друга. <strong>JavaScript</strong> не поддерживает истинный объектно-ориентированный подход к проектированию, но это свойство обеспечивает очень похожие возможности.</p>
<p>Кроме вложения функций, важно отметить, что имеется несколько различных способов объявления функций:</p>
<empty-line/>
<p><code>function myFunction(){</code></p>
<p><code>function nestedFunction1(arg1, arg2, arg3){</code></p>
<p><code>alert(arg1+arg2+arg3);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var nestedFunction2 = function(arg1, arg2, arg3){</code></p>
<p><code>alert(arg1+arg2+arg3);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var nestedFunction3 = new Function('arg1, arg2, arg3', 'alert(arg1+arg2+arg3);');</code></p>
<p><code>}</code></p>
<empty-line/>
<p>В этом примере функции <strong>nestedFunction1</strong>, <strong>nestedFunction2</strong> и <strong>nestedFunction3</strong> являются одинаковыми по своим возможностям. Единственное различие состоит в том, как они определяются. <strong>nestedFunction1</strong> объявлена, как это делалось раньше. Синтаксис для <strong>nestedFunction2</strong> немного отличается. Мы задаем для функции переменную <strong>this.nestedFunction2</strong>. Синтаксис этого объявления будет следующий <strong>имяПеременной= function(аргументы){</strong>. Аналогично для функции <strong>nestedFunction3</strong> задается переменная для новой функции. Однако это объявление существенно отличается, так как мы определяем функцию с помощью строк. Третий вариант используется редко, но является очень полезным, когда используется. Он позволяет создать строку, содержащую код выполняемой функции, а затем определить функцию с помощью этой строки.</p>
<p>В следующей лекции будут рассмотрены массивы.</p>
</section>
<section>
<title>
<p><emphasis>Лекция 5.</emphasis> Строки, числа и массивы</p>
</title>
<p><emphasis>Внутренняя работа присущих JavaScript объектов: строк, чисел и массивов.</emphasis></p>
<p>До сих пор мы рассматривали языковые конструкции <strong>JavaScript</strong>: операторы <strong>if</strong>, циклы, функции и т.д. В этой лекции будет рассмотрена внутренняя работа некоторых присущих <strong>JavaScript</strong> объектов: строк, чисел и массивов.</p>
<p>В <strong>JavaScript</strong> строка является любым фрагментом текста. Как и многие другие объекты в <strong>JavaScript</strong>, строки можно определять несколькими различными способами:</p>
<empty-line/>
<p><code>var myString = 'Hello, World!';</code></p>
<p><code>var myString = new String('Hello, World!');</code></p>
<empty-line/>
<p>Первый метод используется наиболее часто. Второй метод применяется редко и только для гарантии, что получаемый объект является строкой. Например:</p>
<empty-line/>
<p><code>var n = 5;</code></p>
<p><code>var s = new String(n*20);</code></p>
<empty-line/>
<p>В этом примере s будет строкой "<strong>100</strong>". Если просто задать <strong>s</strong> как <strong>n*20</strong>, то <strong>s</strong> будет содержать число <strong>100</strong>. Однако поскольку <strong>JavaScript</strong> является слабо типизированным языком, то эти различия не будут существенно влиять на то, что вы делаете.</p>
<p>Строковые объекты (<strong>var n = new String('Hello World')</strong>) технически являются в <strong>Internet Explorer</strong> более медленными при некоторых операциях, чем строковые литералы (<strong>var n = 'Hello World'</strong>). Однако это поведение совершенно противоположно в других браузерах. В любом браузере различие редко бывает настолько заметно, чтобы об этом беспокоиться.</p>
<p>Единственное важное различие состоит в том, что <strong>eval()</strong> не работает со строковыми объектами.</p>
<p>Что, если в строке имеется апостроф? Следующий код работать не будет:</p>
<empty-line/>
<p><code>var n = 'The dog took it's bone outside';</code></p>
<empty-line/>
<p>Легко видеть, что апостроф в "<strong>it's</strong>" заканчивает строку. Поэтому мы получаем строку "<strong>The dog took it</strong>", за которой следует "<strong>s bone outside'</strong>". Это продолжение само по себе не является допустимым кодом <strong>JavaScript</strong> (или правильным грамматически, если на то пошло), поэтому будет получена ошибка.</p>
<p>Здесь можно сделать две вещи. Так как строка определяется с помощью одиночных или двойных кавычек, то можно задать строку с помощью двойных кавычек. Другая возможность состоит в экранировании апострофа. Чтобы экранировать символ, необходимо просто подставить перед ним символ <strong>\</strong>. Символ <strong>\</strong> в этом контексте сообщает <strong>JavaScript</strong>, что следующий символ необходимо воспринимать в точности так, как он есть, в номинальном значении, а не как специальный символ.</p>
<empty-line/>
<p><code>var n = "The dog took it's bone outside";</code></p>
<p><code>var n = 'The dog took it\'s bone outside';</code></p>
<empty-line/>
<p>Если в строке должен присутствовать символ <strong>\</strong>, то он экранируется таким же образом: <strong>'\\'</strong>.</p>
<p>В предыдущей лекции мы встречались с функциями <strong>indexOf</strong> и <strong>lastIndexOf</strong>. Напомним, что они делают. Функция <strong>indexOf</strong> возвращает число, определяющее первую позицию одной строки в другой. Если разыскиваемая строка не существует, то <strong>indexOf</strong> возвращает <strong>– 1</strong>. Функция <strong>lastIndexOf</strong> идентична <strong>indexOf</strong>, но возвращает не первую позицию вхождения строки, а последнюю.</p>
<p>Тот факт, что функции <strong>indexOf</strong> и <strong>lastIndexOf</strong> возвращают <strong>– 1</strong>, если строка не существует, является очень полезным и позволяет использовать эти функции для достаточно распространенной задачи – проверки того, что одна строка существует внутри другой.</p>
<p>Существует несколько других полезных функций для работы со строками, которые мы перечислим и кратко поясним.</p>
<p><strong>[x] charAt()</strong> сообщает, какой символ находится в определенной позиции строки. Поэтому <strong>'Test'.charAt(1) = 'e'</strong>.</p>
<p><strong>[x] length</strong> сообщает длину строки . <strong>'Test'.length = 4</strong>.</p>
<p><strong>[x] substring()</strong> выдает строку между двумя индексами. <strong>'Test'.substring(1, 2) = 'e'</strong>.</p>
<p><strong>[x] substr()</strong> аналогична <strong>substring()</strong>, только второе число является не индексом, а длиной возвращаемой строки. Если это число указывает на позицию за пределами строки, то <strong>substr()</strong> вернет существующую часть строки. <strong>'Test'.substr(1, 2) = 'es'</strong>;</p>
<p><strong>[x] toLowerCase()</strong> и <strong>toUpperCase()</strong> делают то, что обозначают: преобразуют строку в нижний или верхний регистр символов соответственно. <strong>'Test'.toUpperCase() = 'TEST'</strong>;</p>
<p>Примеры всех приведенных выше функций:</p>
<empty-line/>
<p><code>alert('This is a Test'.indexOf('T')); // 0</code></p>
<p><code>alert('This is a Test'.lastIndexOf('T')); // 10</code></p>
<p><code>alert('This is a Test'.charAt(5)); // i</code></p>
<p><code>alert('This is a Test'.length); // 14</code></p>
<p><code>alert('This is a Test'.substring(5, 9)); // is a</code></p>
<p><code>alert('This is a Test'.substr(5, 9)); // is a Test</code></p>
<p><code>alert('This is a Test'.toUpperCase()); // THIS IS A TEST</code></p>
<p><code>alert('This is a Test'.toLowerCase()); // this is a test</code></p>
<empty-line/>
<p>Последней строковой функцией, которая будет рассмотрена, является <strong>eval()</strong>. <strong>eval()</strong> получает строку и выполняет строку, как если бы это был код <strong>JavaScript</strong>.</p>
<empty-line/>
<p><code>eval("alert('Hello, World!')");</code></p>
<empty-line/>
<p>В этом примере будет выведено сообщение <strong>"Hello, World!"</strong>, как если бы функция <strong>alert</strong> была написана обычным образом. Это может быть очень полезно, так как позволяет создать содержащую код строку, а затем ее выполнить.</p>
<p>Работа с числами в <strong>JavaScript</strong> происходит достаточно просто. В лекциях 1 и 2 было показано, как выполняются базовые арифметические операции, операторы <strong>++</strong> , <strong>– -</strong>, а также <strong>*=</strong>, <strong>+=</strong>, <strong>/=</strong> и <strong>– =</strong>. Мы узнали, что <strong>NaN</strong> означает "Не число" и что делает функция <strong>isNaN()</strong>. Осталось рассмотреть еще только несколько вещей.</p>
<p>Объект <strong>Math</strong> в <strong>JavaScript</strong> содержит функции, позволяющие сделать почти все, что можно сделать с числами помимо обычной арифметики. <strong>Math.PI</strong>, например, содержит просто число <strong>3.141592653589793</strong>. В нем содержатся тригонометрические функции (<strong>sin</strong>, <strong>cos</strong>, <strong>tan</strong>, и т.д.), функции для округления чисел (<strong>Math.floor</strong> возвращает число, округленное с недостатком, <strong>Math.ceil</strong> возвращает число, округленное с избытком, а <strong>Math.round</strong> округляет число "нормально") и многие другие. Существует очень много функций, объяснять которые здесь не имеет смысла. Их всегда можно найти в подходящем справочнике. (Например, <a l:href="http://www.devguru.com/technologies/javascript/10734.asp">http://www.devguru.com/technologies/javascript/10734.asp</a>)</p>
<p>Двумя наиболее распространенными задачами, связанными с числами, являются преобразование числа в строку и строки в число. Как уже говорилось, <strong>JavaScript</strong> является слабо типизированным языком, а это означает, что типы данных не имеют большого значения, но существуют некоторые случаи, когда надо быть уверенным, что имеется число или строка. Если надо сложить, например, <strong>5</strong> и число, которое вводит пользователь, то надо быть уверенным, что введено число, а не слово "<strong>Привет</strong>".</p>
<empty-line/>
<p><code>var n = parseInt("3.14"); // 3</code></p>
<p><code>var n = parseFloat("3.14") // 3.14</code></p>
<empty-line/>
<p>Функция <strong>parseInt</strong> возвращает целое значение своего аргумента. Аргументы "<strong>3.14</strong>", "<strong>3</strong>", "<strong>3.00001</strong>" и "<strong>3.9999</strong>" превратятся в значение <strong>3</strong>. Функция <strong>parseFloat</strong>, с другой стороны, возвращает также любое десятичное значение. Обе эти функции пытаются "очистить" данные перед возвращением числа. Например, <strong>parseInt</strong>("3a") вернет значение <strong>3</strong>.</p>
<p>Существует также несколько методов, которые можно использовать, когда надо преобразовать число в строку:</p>
<empty-line/>
<p><code>var n = 5;</code></p>
<empty-line/>
<p><code>var m = n.toString();</code></p>
<p><code>var m = n+'';</code></p>
<p><code>var m = new String(n);</code></p>
<empty-line/>
<p>Как говорилось ранее, последний метод может быть немного непривычным, поэтому предполагается, что пользователь будет держаться от него в стороне, если только не понадобится использовать объект <strong>String</strong> для специальных целей. Предпочтительным методом является <strong>n.toString()</strong>, но необходимо отметить, что часто используется второй метод. Например, если имеется уведомление <strong>alert('Имеется' + apples + 'яблок')</strong>, то число <strong>apples</strong> автоматически преобразуется в строку.</p>
<p>Если необходимо выполнить строковую операцию с переменной, то необходимо быть уверенным, что имеется строка. Если, например, имеется запись года из 4 цифр и ее надо преобразовать в 2 цифры:</p>
<empty-line/>
<p><code>var year = 2000;</code></p>
<empty-line/>
<p><code>var sYear = year.toString();</code></p>
<p><code>var year2 = sYear.substr(sYear.length-2);</code></p>
<empty-line/>
<p>Можно было бы также легко вычесть <strong>2000</strong> из этой даты, но что, если датой является <strong>1995</strong>? или <strong>1800</strong>? или <strong>2700</strong> или просто <strong>5</strong>? В результате могли бы получиться совершенно неправильные даты, если вычесть <strong>2000</strong> из каждой такой даты. Используемый метод всегда даст правильные две цифры года.</p>
<p>Массив является по сути списком элементов. Каждый элемент массива может быть чем угодно, но обычно они связаны друг с другом. Если, например, необходимо отследить <strong>30</strong> студентов класса, то можно создать массив студентов:</p>
<empty-line/>
<p><code>var students = new Array();</code></p>
<p><code>students[0] = 'Sam';</code></p>
<p><code>students[1] = 'Joe';</code></p>
<p><code>students[2] = 'Sue';</code></p>
<p><code>students[3] = 'Beth';</code></p>
<empty-line/>
<p>Как можно видеть, определить массив очень просто, так же, как и присвоить значения его элементам. Однако пример выше имеет слишком много кода для относительно небольшого результата. Нет ничего удивительного в том, что существует несколько методов для создания массива. Значительно более компактным будет следующий пример:</p>
<empty-line/>
<p><code>var students = ['Sam', 'Joe', 'Sue', 'Beth'];</code></p>
<empty-line/>
<p>Это код создает точно такой же массив, что и предыдущий пример, но, как можно видеть, он значительно более компактный и ничуть не сложнее для понимания. Скобки (<strong>[</strong> и <strong>]</strong>) в этом примере сообщают коду, что будет создан массив. Простая запись <strong>var students = [];</strong> является тем же самым, что и запись <strong>var students = new Array();</strong>. Правда, некоторые люди считают, что использование слова <strong>Array</strong> более наглядно, чем запись <strong>[]</strong>, поэтому можно использовать любой метод записи.</p>
<p>Что можно теперь сделать с этим массивом студентов? Чтобы обратиться к любому элементу массива, необходимо знать его индекс. В первом примере можно видеть, что в скобках находятся числа <strong>(0-3)</strong>. Это индексы. Если требуется узнать имя третьего студента, то надо будет написать <strong>alert(students[2]);</strong>. Почему <strong>2</strong>, а не <strong>3</strong>? Массивы в <strong>JavaScript</strong> начинают индексацию с <strong>0</strong>, а не с <strong>1</strong>. Поэтому первым элементом в нашем массиве будет <strong>students[0]</strong>, вторым – <strong>students[1]</strong>, сотым – <strong>students[99]</strong>, и т.д. Для этого не существует никакой реальной причины, просто так устроен <strong>JavaScript</strong> и многие другие языки программирования. Некоторые другие языки используют в качестве первого индекса <strong>1</strong>.</p>
<p>Наиболее распространенной задачей при работе с массивами, помимо изменения его данных, является проверка его длины, обычно для того, чтобы можно было перебрать весь массив и выполнить некоторую задачу с каждым элементом.</p>
<empty-line/>
<p><code>var students = ['Sam', 'Joe', 'Sue', 'Beth'];</code></p>
<p><code>var suffixes = ['1st', '2nd', '3rd', '4th'];</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;students.length; i++){</code></p>
<p><code>alert(suffixes[i]+' студент -- '+students[i]);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Важный момент, который необходимо знать о массивах, состоит в том, что каждый элемент массива может содержать любой произвольный объект. В этих примерах каждый элемент массива является строкой, но они могут быть также числами, объектами, функциями, даже другими массивами. Электронная таблица (такая, как <strong>Excel</strong>) является хорошим примером массива, содержащего другие массивы. Прежде всего имеется массив столбцов. Каждый столбец будет в свою очередь содержать в себе массив строк. Этот массив создается точно таким же образом, как и массив <strong>students</strong>:</p>
<empty-line/>
<p><code>var spreadsheet = [</code></p>
<p><code>['A1', 'B1', 'C1', 'D1'],</code></p>
<p><code>['A2', 'B2', 'C2', 'D2'],</code></p>
<p><code>['A3', 'B3', 'C3', 'D3'],</code></p>
<p><code>['A4', 'B4', 'C4', 'D4']</code></p>
<p><code>];</code></p>
<empty-line/>
<p>Переносы строк в <strong>JavaScript</strong> обычно не имеют значения. В этом примере переносы строк используются для придания коду большей наглядности и не влияют на код никаким образом.</p>
<p>Можно видеть, что здесь имеется <strong>5</strong> массивов. Четыре внутренних массива (или вложенных массива) содержатся в одном большом массиве, <strong>spreadsheet</strong>. Если потребуется узнать значение на пересечении второго столбца и третьей строки, то можно написать:</p>
<empty-line/>
<p><code>var col2 = spreadsheet[1];</code></p>
<p><code>alert(col2[2]);</code></p>
<empty-line/>
<p><code>// или</code></p>
<empty-line/>
<p><code>alert(spreadsheet[1][2]);</code></p>
<empty-line/>
<p>Оба фрагмента кода делают одно и то же, выводят значение "<strong>C2</strong>".</p>
<p>Существует несколько распространенных операций, которые выполняются с массивами. Первой является добавление элемента в конец массива. Вернемся к массиву <strong>students</strong>, который содержит в данный момент <strong>4</strong> элемента. Чтобы добавить новый элемент, надо просто задать значение для 5-го элемента:</p>
<empty-line/>
<p><code>var students = ['Sam', 'Joe', 'Sue', 'Beth'];</code></p>
<empty-line/>
<p><code>students[4] = 'Mike';</code></p>
<p><code>students[students.length] = 'Sarah';</code></p>
<p><code>students.push('Steve');</code></p>
<empty-line/>
<p><code>// теперь массив содержит 7 элементов: ['Sam', 'Joe', 'Sue', 'Beth', 'Mike', 'Sarah', 'Steve']</code></p>
<empty-line/>
<p>Здесь также существует несколько способов для выполнения этой задачи. Первый метод, <strong>students[4]</strong>, используется редко, так как обычно неизвестно заранее в точности, сколько будет элементов. Поэтому применяется один из двух оставшихся методов. <strong>push</strong> является функцией, которая просто добавляет то, что получает, в конец массива, как и предыдущий метод, использующий свойство <strong>.length</strong>.</p>
<p>Не так часто, но иногда необходимо также удалить объект из массива. В этом случае задействуется функция <strong>splice</strong>, которая позволяет добавить или удалить любое количество элементов массива, но в данный момент мы собираемся использовать ее для удаления одного студента, <strong>Mike</strong>, который переехал в другой город:</p>
<empty-line/>
<p><code>var students = ['Sam', 'Joe', 'Sue', 'Beth', 'Mike', 'Sarah', 'Steve'];</code></p>
<p><code>students.splice(4, 1);</code></p>
<empty-line/>
<p><strong>Splice</strong> в этом примере получает два аргумента: начальный индекс и число элементов для удаления. Так как <strong>Mike</strong> является пятым студентом, то его индекс будет <strong>4</strong>. Будет удален только <strong>1</strong> студент, поэтому здесь используется <strong>1</strong>. В результате имеем массив с удаленным <strong>Mike</strong>:</p>
<empty-line/>
<p><code>['Sam', 'Joe', 'Sue', 'Beth', 'Sarah', 'Steve'];</code></p>
<empty-line/>
<p>Чаще всего точно неизвестно, где в массиве находится элемент. К сожалению, единственным способом выяснить это является перебор всех элементов массива. Можно написать небольшой простой сценарий, который позволит легко добавлять или удалять студентов:</p>
<empty-line/>
<p><code>var students = ['Sam', 'Joe', 'Sue', 'Beth'];</code></p>
<empty-line/>
<p><code>function addStudent(name){</code></p>
<p><code>students.push(name);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function removeStudent(name){</code></p>
<p><code>for(var i=0; i&lt;students.length; i++){</code></p>
<p><code>if(students[i].toLowerCase() == toLowerCase(name)){</code></p>
<p><code>students.splice(i, 1);</code></p>
<p><code>break;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>Имя студента:</code></p>
<empty-line/>
<p><code>Добавить этого студента</code></p>
<p><code>Удалить этого студента</code></p>
<empty-line/>
<p><code>Студенты:</code></p>
<empty-line/>
<p>Единственным новым моментом здесь является слово <strong>break</strong>. <strong>break</strong> останавливает выполнение кода любого цикла, в котором находится: цикла <strong>for</strong>, цикла <strong>do</strong> или <strong>switch</strong>. Поэтому в данном случае, когда удаляемый студент найден, мы прерываем цикл <strong>for</strong>, так как выполнили свою задачу.</p>
<p>Часто бывает необходимо преобразовать массив в строку или строку в массив. Имеется две функции, которые могут легко это сделать: <strong>join</strong> и <strong>split</strong>. Функция <strong>join</strong> получает массив и преобразует его в строку с помощью разделителя, заданного в <strong>join</strong>. Функция <strong>split</strong> действует в обратном направлении и делает массив из строки, определяя новый элемент c помощью разделителя, заданного в <strong>split</strong>:</p>
<empty-line/>
<p><code>var myString = 'apples are good for your health';</code></p>
<p><code>var myArray = myString.split('a');</code></p>
<p><code>// строка myString разбивается на элементы на каждом найденном символе 'a'.</code></p>
<p><code>alert(myArray.join(', '));</code></p>
<p><code>// преобразуем myArray снова в строку с помощью запятой,</code></p>
<p><code>// так что можно видеть каждый элемент</code></p>
<p><code>alert(myArray.join('a'));</code></p>
<p><code>// теперь преобразуем myArray снова в строку с помощью символа 'a',</code></p>
<p><code>// так что снова получается исходная строка</code></p>
<empty-line/>
<p>Еще две полезные функции для работы с массивами – <strong>pop</strong> и <strong>shift</strong>. Функция <strong>pop</strong> удаляет последний элемент из массива и возвращает его. Функция <strong>shift</strong> удаляет первый элемент из массива и возвращает его.</p>
<empty-line/>
<p><code>var students = ['Sam', 'Joe', 'Sue', 'Beth'];</code></p>
<empty-line/>
<p><code>while(students.length&gt;0){</code></p>
<p><code>alert(students.pop());</code></p>
<p><code>}</code></p>
<empty-line/>
<p>К сожалению, при этом массив был уничтожен: он теперь пуст. Иногда именно это и надо сделать. Если требуется просто очистить массив, то проще всего задать его длину (<strong>length</strong>) равной <strong>0</strong>:</p>
<empty-line/>
<p><code>students.length = 0</code></p>
<empty-line/>
<p>Теперь массив пуст. Даже если снова задать длину массива больше <strong>0</strong>, все данные в массиве уже будут уничтожены.</p>
<p>Все использованные до сих пор массивы называются "индексными массивами", так как каждый элемент массива имеет индекс, который необходимо использовать для доступа к элементу. Существуют также "ассоциативные массивы", в которых каждый элемент массива ассоциирован с именем в противоположность индексу:</p>
<empty-line/>
<p><code>var grades = [];</code></p>
<p><code>grades['Sam'] = 90;</code></p>
<p><code>grades['Joe'] = 85;</code></p>
<p><code>grades['Sue'] = 94;</code></p>
<p><code>grades['Beth'] = 82;</code></p>
<empty-line/>
<p>Ассоциативные массивы действуют немного иначе, чем индексные. Прежде всего, длина массива в этом примере будет равна <strong>0</strong>. Как же узнать, какие элементы находятся в массиве? Единственный способ сделать это – использовать цикл "<strong>for-in</strong> ":</p>
<empty-line/>
<p><code>for(student in grades){</code></p>
<p><code>alert("Оценка" + student + "будет:" + grades[student]);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Синтаксис цикла <strong>for-in</strong> следующий: "<strong>for(item in object){</strong>". Цикл пройдет через все элементы в объекте, и элемент будет именем элемента. В данном случае элементом является "<strong>Sam</strong>", затем "<strong>Joe</strong>", "<strong>Sue</strong>" и "<strong>Beth</strong>".</p>
<p>Последнее замечание о массивах состоит в том, что в действительности можно объединять ассоциативные и индексные массивы, хотя это обычно не рекомендуется, так как может вызывать некоторые проблемы. При правильном использовании, однако, можно с успехом это применять.</p>
<empty-line/>
<p><code>var students = ['Sam', 'Joe', 'Sue', 'Beth'];</code></p>
<empty-line/>
<p><code>students['Sam'] = 90;</code></p>
<p><code>students['Joe'] = 85;</code></p>
<p><code>students['Sue'] = 94;</code></p>
<p><code>students['Beth'] = 82;</code></p>
<empty-line/>
<p><code>alert('Всего имеется '+(students.length)+' студентов: '+students.join(', '));</code></p>
<p><code>for(var i=0; i&lt;students.length; i++){</code></p>
<p><code>alert("Оценка" +students[i]+"будет: "+students[students[i]]);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Хотя это может показаться немного сложным, здесь нет ничего такого, о чем не говорилось в этой лекции.</p>
<p>Теперь читатель должен достаточно хорошо понимать основные типы данных <strong>JavaScript</strong>: строки, числа и массивы. В следующей лекции будет рассмотрена Объектная модель документа, или <strong>DOM</strong> (Document Object Model).</p>
</section>
<section>
<title>
<p><emphasis>Лекция 6.</emphasis> Объектная модель документа</p>
</title>
<p><emphasis>Объектная модель документа или коротко DOM (Document Object Model). Функции document.forms, document.getElementById, document.createElement и некоторые другие, которые встроены в объект document.</emphasis></p>
<p>Эта лекция посвящена Объектной модели документа, или коротко <strong>DOM</strong> (Document Object Model). <strong>DOM</strong> является просто специальным термином для "всего на Web-странице". Объектная модель включает каждую таблицу, изображение, ссылку, поле формы и т.д. на Web-странице. <strong>JavaScript</strong> позволяет манипулировать с любым элементом на странице в реальном времени. Можно скрывать или полностью удалять любой элемент, добавлять элементы, копировать их, изменять такие свойства, как цвет, ширина, высота, и т.д., а при некотором воображении можно даже реализовать функции перетаскивания, анимации и почти все остальное, что можно придумать.</p>
<p>Прежде всего, необходимо понять, что с точки зрения браузера страница <strong>HTML</strong> является точно тем же, что и документ <strong>XML</strong>. Если читатель имеет опыт работы с <strong>XML</strong>, то сможет понять обработку <strong>DOM</strong> достаточно легко. Но в любом случае это в действительности не сложно. Существует прекрасный справочник по адресу (<a l:href="http://www.devguru.com/technologies/xml_dom/index.asp">http://www.devguru.com/technologies/xml_dom/index.asp</a>), который подробно описывает каждый метод обработки <strong>DOM</strong>, но к концу этой лекции читатель в основном поймет, как это работает.</p>
<p>Те, кто знает, что такое документ <strong>XML</strong>, могут пропустить этот раздел. Остальным необходимо его прочитать.</p>
<p>Будем надеяться, что читатель в какой-то степени знаком с <strong>HTML</strong>. Это то, из чего состоит (почти) каждая Web-страница. Каждое изображение, ссылка, таблица, поле формы и т.д. имеют свой собственный тег. Ниже приведен пример простой страницы <strong>HTML</strong>:</p>
<empty-line/>
<p><code>&lt;HTML&gt;</code></p>
<p><code>&lt;BODY&gt;</code></p>
<p><code>&lt;table border="0" cellspacing="2" cellpadding="5"&gt;</code></p>
<p><code>&lt;tr&gt;</code></p>
<p><code>&lt;td colspan="2"&gt;&lt;img src="Greetings.jpg" id="greetingImg" /&gt;&lt;/td&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<p><code>&lt;tr&gt;</code></p>
<p><code>&lt;td&gt;</code></p>
<p><code>Добро пожаловать на мою страницу HTML!</code></p>
<p><code>&lt;br /&gt;</code></p>
<p><code>&lt;a href="somelink.html" id="myLink" &gt;Щелкните здесь!&lt;/a&gt;</code></p>
<p><code>&lt;/td&gt;</code></p>
<p><code>&lt;td&gt;&lt;img src="hello.jpg" id="helloImg" /&gt;&lt;/td&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<p><code>&lt;/table&gt;</code></p>
<p><code>&lt;/BODY&gt;</code></p>
<p><code>&lt;/HTML&gt;</code></p>
<empty-line/>
<p>Это просто обычная страница <strong>HTML</strong>. Возможно, вы не знаете о том, что это также пример документа <strong>XML</strong>. Здесь нас интересует то, что каждый элемент является потомком и/или предком другого элемента. Первое изображение находится внутри тега <strong>TD</strong>, который находится внутри тегов <strong>TR</strong>, <strong>TABLE</strong>, <strong>BODY</strong> и <strong>HTML</strong>. Двигаясь в другом направлении, можно видеть, что тег <strong>BODY</strong> имеет одного "потомка" – тег <strong>TABLE</strong>. Этот тег <strong>TABLE</strong> имеет в качестве потомков два тега <strong>TR</strong> и т.д. По сути именно так мы перемещаемся в документе <strong>XML</strong> или <strong>HTML DOM</strong> – двигаясь от потомка к предку или от предка к потомку.</p>
<p>Изображение может помочь лучше понять отношения предок-потомок в этом коде.</p>
<empty-line/>
<image l:href="#img1.png"/>
<empty-line/>
<subtitle>Блок-схема документа</subtitle>
<p>Необходимо также отметить атрибуты в некоторых из этих тегов. Например, тег <strong>TABLE</strong> (<strong>&lt;table border="0" cellspacing="2" cellpadding="5"&gt;</strong>) имеет <strong>3</strong> заданных атрибута: <strong>border</strong>, <strong>cellspacing</strong> и <strong>cellpadding</strong>. При изменении <strong>DOM</strong> часто бывает необходимо изменить эти атрибуты. Можно, например, изменить атрибут <strong>SRC</strong> тега <strong>IMG</strong>, чтобы изменить выводимое изображение. Это часто делают, например, для создания эффекта изменения изображения, на которое направлен указатель (<strong>rollover</strong>).</p>
<p>Теперь, имея общее представление о компоновке страницы, можно начинать ее модификацию. Начнем с создания простого эффекта изменения изображения:</p>
<empty-line/>
<p><code>&lt;img src="button_off.gif"</code></p>
<p><code>onmouseover="this.src='button_over.gif';"</code></p>
<p><code>onmousedown="this.src='button_down.gif';"</code></p>
<p><code>onmouseout ="this.src='button_off.gif';"</code></p>
<p><code>onmouseup ="this.src='button_over.gif';"&gt;</code></p>
<empty-line/>
<p>В этом коде присутствуют 4 события изображения: <strong>onmouseover</strong>, <strong>onmousedown</strong>, <strong>onmouseout</strong> и <strong>onmouseup</strong>. Каждое из этих событий имеет присоединенный простой фрагмент кода <strong>JavaScript</strong>, который изменяет атрибут <strong>src</strong> изображения. Создавая три разных изображения, можно легко и быстро создать изображение с тремя сменяющими друг друга состояниями.</p>
<p>Одной из задач, которая становится все более распространенной в современных приложениях <strong>JavaScript</strong>, является возможность добавления или удаления элементов страницы. Предположим, что имеется форма, которая позволяет послать кому-нибудь ссылку. Обычно используется одно поле ввода для адреса e-mail и второе – для имени получателя. Если требуется послать ссылку нескольким адресатам, то либо придется посылать форму несколько раз, либо можно было бы разместить на странице более одного набора полей имя/e-mail. Но в этом случае мы все еще ограничены заданным числом контактов. Если имеется пространство для <strong>5</strong> контактов и необходимо послать ссылку <strong>20</strong> людям, то форму придется заполнять <strong>4</strong> раза.</p>
<p><strong>JavaScript</strong> позволяет обойти эту проблему, делая возможным динамическое дополнение и удаление содержимого страницы:</p>
<empty-line/>
<p><code>1 var inputs = 0;</code></p>
<p><code>2 function addContact(){</code></p>
<p><code>3 var table = document.getElementById('contacts');</code></p>
<p><code>4</code></p>
<p><code>5 var tr = document.createElement('TR');</code></p>
<p><code>6 var td1 = document.createElement('TD');</code></p>
<p><code>7 var td2 = document.createElement('TD');</code></p>
<p><code>8 var td3 = document.createElement('TD');</code></p>
<p><code>9 var inp1 = document.createElement('INPUT');</code></p>
<p><code>10 var inp2 = document.createElement('INPUT');</code></p>
<p><code>11</code></p>
<p><code>12 if(inputs&gt;0){</code></p>
<p><code>13 var img = document.createElement('IMG');</code></p>
<p><code>14 img.setAttribute('src', 'delete.gif');</code></p>
<p><code>15 img.onclick = function(){</code></p>
<p><code>16 removeContact(tr);</code></p>
<p><code>17 }</code></p>
<p><code>18 td1.appendChild(img);</code></p>
<p><code>19 }</code></p>
<p><code>20</code></p>
<p><code>21 inp1.setAttribute("Name", "Name" +inputs);</code></p>
<p><code>22 inp2.setAttribute("Email", "Email"+inputs);</code></p>
<p><code>23</code></p>
<p><code>24 table.appendChild(tr);</code></p>
<p><code>25 tr.appendChild(td1);</code></p>
<p><code>26 tr.appendChild(td2);</code></p>
<p><code>27 tr.appendChild(td3);</code></p>
<p><code>28 td2.appendChild(inp1);</code></p>
<p><code>29 td3.appendChild(inp2);</code></p>
<p><code>30</code></p>
<p><code>31 inputs++;</code></p>
<p><code>32 }</code></p>
<p><code>33 function removeContact(tr){</code></p>
<p><code>34 tr.parentNode.removeChild(tr);</code></p>
<p><code>35 }</code></p>
<p><code>36 &lt;table&gt;</code></p>
<p><code>37 &lt;tbody id="contacts"&gt;</code></p>
<p><code>38 &lt;tr&gt;</code></p>
<p><code>39 &lt;td colspan="3"&gt;&lt;a href="javascript:addContact();"&gt;Добавьте контакт&lt;/a&gt;&lt;/td&gt;</code></p>
<p><code>40 &lt;/tr&gt;</code></p>
<p><code>41 &lt;tr&gt;</code></p>
<p><code>42 &lt;td&gt;&lt;/td&gt;</code></p>
<p><code>43 &lt;td&gt;Name &lt;/td&gt;</code></p>
<p><code>44 &lt;td&gt;Email&lt;/td&gt;</code></p>
<p><code>45 &lt;/tr&gt;</code></p>
<p><code>46 &lt;/tbody&gt;</code></p>
<p><code>47 &lt;/table&gt;</code></p>
<empty-line/>
<p>Демонстрация</p>
<empty-line/>
<p><code>Добавьте контакт</code></p>
<empty-line/>
<p><code>Name Email</code></p>
<empty-line/>
<p>Возможно вам не приходилось ранее использовать тег <strong>TBODY</strong>. Многие браузеры автоматически добавляют этот тег в <strong>DOM</strong>, не сообщая об этом. Если необходимо изменить содержимое таблицы, то в действительности необходимо изменить содержимое <strong>TBODY</strong>. Во избежание возможных недоразумений мы просто добавили тег <strong>TBODY</strong>, чтобы каждый мог бы его видеть. Все это может показаться достаточно сложным, но здесь очень мало нового материала.</p>
<p>Прежде всего здесь имеется новая функция: <strong>document.createElement</strong>. Функция <strong>createElement</strong> создает задаваемый аргументом элемент. Можно видеть, что в строках сценария с 5 по 10 создается несколько элементов. В действительности создается новая строка <strong>TR</strong>, которая вставляется в таблицу в строках 37-46. В результате новая строка <strong>TR</strong> будет выглядеть следующим образом:</p>
<empty-line/>
<p><code>&lt;tr&gt;</code></p>
<p><code>&lt;td&gt;</code></p>
<p><code>&lt;img src="delete.gif"&gt;</code></p>
<p><code>&lt;/td&gt;</code></p>
<p><code>&lt;td&gt;</code></p>
<p><code>&lt;input name="Name1"&gt;</code></p>
<p><code>&lt;/td&gt;</code></p>
<p><code>&lt;td&gt;</code></p>
<p><code>&lt;input name="Email1"&gt;</code></p>
<p><code>&lt;/td&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<empty-line/>
<p>Другими словами, мы создали 7 элементов: 1 <strong>TR</strong>, 3 <strong>TD</strong>, 2 <strong>INPUT</strong> и 1 <strong>IMG</strong>. Тег <strong>IMG</strong> будет использоваться как изображение кнопки "<strong>Удалить</strong>". Так как пользователь должен всегда видеть по крайней мере 1 строку ввода, то первую строку удалить невозможно. Поэтому в 12 строке сценария проверяется, что создается первая строка. Если строка не первая, то добавляется изображение.</p>
<p>После создания всех этих элементов остается в действительности поместить их в документ. Каждый элемент на странице имеет встроенную функцию <strong>appendChild</strong>, которую можно использовать для добавления к этому элементу потомка. Когда добавляется потомок, то он добавляется как последний элемент, поэтому если таблица уже имеет в качестве потомков <strong>10</strong> тегов <strong>TR</strong> и добавляется еще один, то он будет добавлен как 11-ый тег <strong>TR</strong>. Мы начинаем с получения ссылки на таблицу (строка 3). Затем мы добавляем <strong>TR</strong> к этой таблице (строка 24) и добавляем затем 3 <strong>TD</strong> (строки 25-27). Второй и третий <strong>TD</strong> содержат поле ввода, поэтому мы добавляем эти поля ввода (28-29).</p>
<p>Вот и все! Теперь у нас есть новый элемент <strong>TR</strong>, и он находится на странице. Осталось пояснить еще пару моментов. Чтобы форма была обработана правильно, все поля ввода должны иметь различные имена. Поэтому мы задаем имя двух полей ввода на основе счетчика (21-22), а затем увеличиваем счетчик (31). Это делается с помощью еще одной новой функции <strong>setAttribute</strong>, которая имеет два параметра: имя атрибута и значение атрибута. Для нее существует дополнительная функция <strong>getAttribute</strong>, которая имеет только один аргумент: имя атрибута, значение которого надо получить.</p>
<empty-line/>
<p><code>element.setAttribute("name", "elementName")</code></p>
<empty-line/>
<p>по сути то же самое, что</p>
<empty-line/>
<p><code>element.name="elementName"</code></p>
<empty-line/>
<p>Однако задание атрибута непосредственно, как в предыдущем примере, может иногда вызывать некоторые проблемы для различных браузеров или для некоторых специфических атрибутов. Поэтому хотя любой метод обычно будет работать, предпочтительным является первый метод, использующий <strong>setAttribute</strong>.</p>
<p>Необходимо также позаботиться о кнопке удаления. Мы уже знаем, что кнопка удаления для первой строки полей не создается, но необходимо заставить ее работать для всех остальных. Это делается в строках кода 15-16. Здесь к изображению добавлена функция <strong>onclick</strong>, которая вызывает функцию <strong>removeContact</strong>, передавая элемент <strong>TR</strong> в качестве единственного аргумента.</p>
<p>Взглянув на функцию <strong>removeContact</strong>, можно видеть, что сначала происходит обращение <strong>tr.parentNode</strong> к функции <strong>parentNode</strong>, которая является еще одной функцией для работы с <strong>DOM</strong>. Она просто возвращает порождающий элемент для текущего элемента. Если посмотреть на изображенное ранее дерево документа, то видно, что <strong>parentNode</strong> вернет элемент непосредственно над элементом, на котором он вызван. Поэтому, если вызвать <strong>parentNode</strong> на одиночном элементе <strong>A</strong> в этом дереве, то будет получена ссылка на элемент <strong>TD</strong> над ним.</p>
<p>Поэтому <strong>tr.parentNode</strong> возвращает ссылку на элемент <strong>TABLE</strong> над <strong>TR</strong>. Затем вызывается функция <strong>removeChild</strong> на этом элементе <strong>TABLE</strong>, которая просто удаляет у предка указанного потомка.</p>
<p>Взглянув еще раз на строку 34, можно теперь увидеть, что она просто говорит: "<strong>Удалить элемент <strong>TR</strong> у его предка</strong>" или еще проще "<strong>Удалить элемент TR</strong>".</p>
<p>Ко всем потомкам элемента можно обратиться с помощью атрибута <strong>childNodes</strong>, который возвращает массив, содержащий все узлы потомки текущего элемента. Можно также использовать атрибуты <strong>firstChild</strong> и <strong>lastChild</strong> на любом элементе, чтобы получить ссылки на первый или на последний элемент.</p>
<p>Чтобы увидеть, как это работает, давайте напишем сценарий для раскраски чередующихся строк <strong>TR</strong> в таблице:</p>
<empty-line/>
<p><code>function setColors(tbody, color1, color2){</code></p>
<p><code>var colors = [color1, color2];</code></p>
<p><code>var counter = 0;</code></p>
<p><code>var tr = tbody.firstChild;</code></p>
<empty-line/>
<p><code>while(tr){</code></p>
<p><code>tr.style.backgroundColor = colors[counter++ % 2];</code></p>
<p><code>tr = tr.nextSibling;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Демонстрация</p>
<empty-line/>
<p><code>Row 1</code></p>
<p><code>Row 2</code></p>
<p><code>Row 3</code></p>
<p><code>Row 4</code></p>
<p><code>Row 5</code></p>
<p><code>Row 6</code></p>
<empty-line/>
<p><code>Color #1: Color #2: Раскрасьте таблицу</code></p>
<empty-line/>
<p>При рассмотрении этого небольшого фрагмента кода мало что нужно пояснять в том, как можно получить этот интересный небольшой эффект. Код начинается с получения ссылки на первый элемент <strong>TR</strong> в таблице с помощью метода <strong>firstChild</strong>. Затем каждый <strong>TR</strong> раскрашивается по очереди двумя разными цветами, используя <strong>tr.style</strong>. Цвет фона задается одним из двух цветов из массива <strong>colors</strong>. Если <strong>counter</strong> имеет четное значение, то цвет фона задается как <strong>color1</strong>. Иначе он задается как <strong>color2</strong>. Это реализуется с помощью оператора деления по модулю (<strong>%</strong>). Для тех, кто забыл, напомним, что операция вычисляет остаток при делении. <strong>5/2 = 2</strong> с остатком <strong>1</strong>. Поэтому <strong>5 % 2 (5 по модулю 2) = 1</strong>.</p>
<p>Здесь не будет обсуждаться в данный момент изменение стилей, но достаточно сказать, что <strong>element.style</strong> предоставляет доступ ко всему, что можно задать с помощью таблицы стилей. Если нужно, например, задать стиль элемента, то можно прочитать/записать весь стиль с помощью <strong>element.style.cssText</strong>.</p>
<p>После задания цвета фона берется следующий элемент <strong>TR</strong> в таблице. Это делается с помощью функции <strong>nextSibling</strong>, которая возвращает следующий элемент в <strong>DOM</strong>, с тем же предком, что и текущий элемент. Если посмотреть на тег <strong>TABLE</strong>, то все его потомки являются элементами <strong>TR</strong>, поэтому <strong>nextSibling</strong> будет в цикле перебирать все элементы <strong>TR</strong>. Если отыскивается элемент <strong>TR</strong> с потомками, состоящими из элементов <strong>TD</strong>, то <strong>nextSibling</strong> будет циклически перебирать все элементы <strong>TD</strong>. Когда элементов <strong>TR</strong> больше не останется, цикл автоматически закончится, так как <strong>TR</strong> будет неопределенным, что в <strong>JavaScript</strong> оценивается как <strong>false</strong>.</p>
<p>С целью рассмотрения оператора <strong>childNodes</strong> и функции <strong>getElementsByTagName</strong> перепишем приведенный пример немного по-другому:</p>
<empty-line/>
<p><code>function setColors(tbody, color1, color2){</code></p>
<p><code>var colors = [color1, color2];</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;tbody.childNodes.length; i++){</code></p>
<p><code>tbody.childNodes[i].style.backgroundColor = colors[i % 2];</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function setColors(tbody, color1, color2){</code></p>
<p><code>var colors = [color1, color2];</code></p>
<p><code>var trs = tbody.getElementsByTagName('TR');</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;trs.length; i++){</code></p>
<p><code>trs[i].style.backgroundColor = colors[i % 2];</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Обе эти функции делают то же самое, что и первая функция <strong>setColors</strong>, но написано это немного по-другому. Первая функция использует атрибут <strong>childNodes</strong>. Как ранее говорилось, <strong>childNodes</strong> содержит массив, элементами которого являются потомки. Поэтому мы циклически перебираем <strong>tbody.childNodes</strong> и изменяем цвет каждого потомка, которые все должны быть элементами <strong>TR</strong>.</p>
<p>Другая функция использует новую функцию <strong>getElementsByTagName</strong>, которая выдает массив всех элементов с указанным именем тега. Так как нам требуются все элементы <strong>TR</strong>, то мы просто передаем в функцию <strong>'TR'</strong> и получаем список всех элементов <strong>TR</strong> в таблице. После этого код почти идентичен предыдущей функции.</p>
<p>Работа с текстом немного отличается от работы с другими элементами <strong>DOM</strong>. Первое: каждый фрагмент текста на странице помещен в невидимый узел <strong>#TEXT</strong>. Поэтому следующий код <strong>HTML</strong></p>
<empty-line/>
<p><code>&lt;div id="ourTest"&gt;this is &lt;a href="link.html"&gt;a link&lt;/a&gt; and an image: &lt;img src="img.jpg"&gt;&lt;/div&gt;</code></p>
<empty-line/>
<p>имеет четыре корневых элемента: текстовый узел со значением "<strong>this is</strong>", элемент <strong>A</strong>, еще один текстовый узел со значением "<strong>and an image:</strong>" и, наконец, элемент <strong>IMG</strong>. Элемент <strong>A</strong> имеет конечный текстовый узел в качестве потомка со значением "<strong>a link</strong>". Когда необходимо изменить текст, то прежде всего необходимо получить этот "невидимый" узел. Если мы хотим изменить текст "<strong>and an image:</strong>", то необходимо написать:</p>
<empty-line/>
<p><code>document.getElementById('ourTest').childNodes[2].nodeValue = 'our new text';</code></p>
<empty-line/>
<p><strong>document.getElementById('ourTest')</strong> дает нам тег <strong>div. childNodes[2]</strong> дает узел текста "<strong>and an image:</strong>" и наконец <strong>nodeValue</strong> изменяет значение этого узла текста.</p>
<p>Что, если требуется добавить к этому еще текст, но не в конце, а перед "<strong>a link</strong>"?</p>
<empty-line/>
<p><code>var newText = document.createTextNode('our new text');</code></p>
<p><code>var ourDiv = document.getElementById('ourTest');</code></p>
<p><code>ourDiv.insertBefore(newText, ourDiv.childNodes[1]);</code></p>
<empty-line/>
<p>Первая строка показывает, как создать текст с помощью <strong>document.createTextNode</strong>. Это аналогично функции использованной ранее функции <strong>document.createElement</strong>. Третья строка содержит еще одну новую функцию <strong>insertBefore</strong>, которая аналогична <strong>appendChild</strong>, за исключением того, что имеет два аргумента: добавляемый элемент и существующий элемент, перед которым надо сделать вставку. Так как мы хотим добавить новый текст перед элементом <strong>A</strong> и знаем, что элемент <strong>A</strong> является вторым элементом в <strong>div</strong>, то мы используем <strong>ourDiv.childNodes[1]</strong> в качестве второго аргумента для <strong>insertBefore</strong>.</p>
<p>По большей части это все манипуляции с <strong>DOM</strong>. Если требуется создать, например, поле с изменяемым размером, то для изменения ширины и высоты поля будут использоваться те же функции мыши и функции <strong>getAttribute</strong> и <strong>setAttribute</strong>. Очень похожим образом, если изменять верхнюю и левую позицию стиля элемента, то можно перемещать элементы по странице, либо в ответ на ввод мыши (перетаскивание), либо по таймеру (анимация).</p>
<p>В качестве последнего замечания к этой лекции: одним из наиболее полезных средств при попытке протестировать или отладить код <strong>JavaScript</strong>, который изменяет <strong>DOM</strong>, является сценарий обхода дерева <strong>DOM</strong>. Проще говоря – это сценарий, который показывает каждый элемент и каждый атрибут объекта <strong>DOM</strong>. Описание этого кода выходит за рамки этой лекции, но он мог бы, например, показывать все атрибуты и объекты-потомки любого получаемого в качестве аргумента объекта.</p>
<p>Теперь можно включить свое воображение и экспериментировать, так как почти нет ничего такого, чего нельзя сделать со страницей <strong>HTML</strong>, когда вы знаете, как обращаться с <strong>DOM</strong>. В следующей лекции будут рассмотрены объекты окна и документа.</p>
</section>
<section>
<title>
<p><emphasis>Лекция 7.</emphasis> Объект документа и объект окна</p>
</title>
<p><emphasis>Объект документа (document) и объект окна (window). Функции setTimeout и setInterval, window.opener, document.body и document.documentElement. Cвойства документа title, referer и cookies.</emphasis></p>
<p>В предыдущей лекции рассматривалось использование объекта документа. Были показаны функции <strong>document.forms</strong>, <strong>document.getElementById</strong>, <strong>document.createElement</strong> и некоторые другие, которые встроены в объект <strong>document</strong>. В этой лекции будут подробно рассмотрены объект документа (<strong>document</strong>) и объект окна (<strong>window</strong>), которые обладают многими полезными функциями.</p>
<p>Объект <strong>document</strong> представляет реальное содержимое страницы и поэтому имеет функции, которые помогают изменить саму страницу. Например, запись на странице происходит с помощью <strong>document.write</strong>, а обращение к форме – с помощью <strong>document.forms</strong>.</p>
<p>Как упоминалось в шестой лекции, каждый объект на странице является потомком или предком какого-то другого объекта. Все это представляет большое дерево. Объект <strong>window</strong> находится в вершине этого дерева, а все остальное содержится в нем. Объект <strong>window</strong> указывает на реальное окно браузера. Если требуется, например, открыть новое окно или изменить размер текущего, то для этого используются функции объекта <strong>window</strong>.</p>
<p>Объект <strong>window</strong>, кроме того, что находится в вершине <strong>DOM</strong>, является также глобальным объектом. Во второй лекции мы говорили о том, что любая переменная обладает глобальной или локальной областью действия. Если она имеет глобальную область действия, то она доступна в любом месте сценария <strong>JavaScript</strong>. Обладание глобальной областью действия означает также, что переменная соединена непосредственно с объектом <strong>window</strong>. Любой код <strong>JavaScript</strong>, который не находится внутри какой-то функции, находится в глобальном объекте <strong>window</strong>.</p>
<p>В связи с этим не требуется писать <strong>window</strong> при обращении к функциям или переменным объекта <strong>window</strong>, как в случае использования некоторых других функций, таких, как <strong>document.getElementById. alert()</strong> является примером функции, которую можно вызвать либо как <strong>window.alert()</strong>, либо просто <strong>alert()</strong>.</p>
<p>Прежде всего объект <strong>window</strong> предоставляет доступ к информации об окне:</p>
<empty-line/>
<table>
<tr>
<th>Свойство</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>window.location</strong></td>
<td>возвращает текущий <strong>URL</strong> окна</td>
</tr>
<tr>
<td><strong>window.opener</strong></td>
<td>Если окно было открыто другим окном (с помощью <strong>window.open</strong>), то возвращается ссылка на открывающее окно, иначе <strong>null</strong></td>
</tr>
<tr>
<td><strong>MSIE</strong>: <strong>window.screenTop</strong> Другие: <strong>window.screenY</strong></td>
<td>Возвращает верхнюю позицию окна. Отметим, что эти значения в <strong>MSIE</strong> существенно отличаются от других браузеров. <strong>MSIE</strong> возвращает верхнюю позицию области содержимого (ниже адресной строки, кнопок, и т.д.). Другие браузеры возвращают верхнюю позицию реального окна (выше кнопки закрытия)</td>
</tr>
<tr>
<td><strong>MSIE</strong>: <strong>window.screenLeft</strong> Другие: <strong>window.screenX</strong></td>
<td>Возвращает левую позицию окна с такими же различиями, как и для <strong>screenTop</strong> и <strong>screenY</strong></td>
</tr>
</table>
<empty-line/>
<p>Положение окна на экране пользователя редко бывает необходимо, но два других свойства, <strong>location</strong> и <strong>opener</strong>, будут очень полезны. Свойство <strong>window.location</strong> выполняет две функции. Если изменить его с помощью <strong>JavaScript</strong>, например, <strong>window.location='http://www.htmlgoodies.com'</strong>, то браузер будет перенаправлен на эту страницу. Чтение <strong>window.location</strong> выдает адрес текущего документа. Зачем это нужно знать? Обычно адрес страницы не нужен, но может потребоваться строка запроса или анкер. Возьмем, например, следующий <strong>URL</strong>:</p>
<p><a l:href="http://www.somesite.com/page.asp?action=browse&amp;id=5#someAnchor">http://www.somesite.com/page.asp?action=browse&amp;id=5#someAnchor</a>.</p>
<p>Этот <strong>URL</strong> можно разбить на три части:</p>
<empty-line/>
<table>
<tr>
<td><strong>URL</strong>:</td>
<td>http://www.somesite.com/page.asp</td>
</tr>
<tr>
<td>Строка запроса:</td>
<td>action=browse&amp;id=5</td>
</tr>
<tr>
<td>Анкер:</td>
<td>someAnchor</td>
</tr>
</table>
<empty-line/>
<p>Так как <strong>window.location</strong> содержит всю эту информацию, то можно написать функцию, которая будет возвращать переменную querystring (строку запроса). Это аналогично <strong>request.querystring</strong> в <strong>ASP</strong> или <strong>$_GET</strong> в <strong>PHP</strong>, если вы знакомы с каким-либо из этих языков:</p>
<empty-line/>
<p><code>function queryString(val){</code></p>
<p><code>var q = unescape(location.search.substr(1)).split('&amp;');</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;q.length; i++){</code></p>
<p><code>var t=q[i].split('=');</code></p>
<p><code>if(t[0].toLowerCase()==val.toLowerCase()) return t[1];</code></p>
<p><code>}</code></p>
<p><code>return '';</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Для предыдущего <strong>URL</strong> функция <strong>queryString('action')</strong> вернет <strong>'browse'</strong>. Мы видим здесь новую функцию <strong>window.unescape</strong>. Функция <strong>unescape</strong>, а также ее дополнительная функция <strong>escape</strong>, используются в соединении с <strong>window.location</strong>. При передаче данных в строке запроса она должна быть экранирована (escaped), чтобы она не влияла на саму строку запроса. Если, например, среди данных имеется знак амперсанд (<strong>&amp;</strong>), то необходимо его экранировать, чтобы можно было различить этот знак в данных и тот <strong>&amp;</strong>, который разделяет два различных значения. Функция <strong>escape</strong> подготавливает посылаемые данные для использования в качестве значения <strong>querystring</strong>, поэтому она используется при задании <strong>window.location</strong>. Например:</p>
<empty-line/>
<p><code>window.location='/page.asp?name='+escape(SomeInputBox.value);</code></p>
<empty-line/>
<p>Функция <strong>unescape</strong> делает обратное и позволяет получить "нормальный" текст из <strong>window.location</strong>.</p>
<p>Вернемся к свойствам <strong>window</strong>, где имеется свойство <strong>opener</strong>. Это свойство используется в соединении с обычно используемой функцией <strong>window.open</strong>, которая позволяет открывать новое окно браузера и, для некоторых свойств управлять его выводом. Блокировщики всплывающих окон очень часто будут препятствовать открытию окна с помощью <strong>window.open</strong>, если в этот процесс не вовлечен щелчок мышью. Поэтому, если в коде имеется вызов <strong>window.open</strong> и при этом пользователь не щелкает на ссылке или чем-то подобном, то скорее всего это не будет работать.</p>
<p>Функция <strong>window.open</strong> получает до <strong>3</strong> аргументов: <strong>URL</strong> окна, которое надо открыть, имя окна и свойства окна.</p>
<empty-line/>
<p><code>var newWindow=window.open('', 'newWindow', 'width=200,height=200');</code></p>
<p><code>newWindow.document.write('Это окно будет закрыто через 2 секунды');</code></p>
<p><code>setTimeout(function(){ newWindow.close(); }, 2000);</code></p>
<empty-line/>
<p>Третий аргумент <strong>window.open</strong> получает строку аргументов. Обычно используются следующие:</p>
<p><strong>[x] width</strong>, <strong>height</strong> – задают размеры окна;</p>
<p><strong>[x] left</strong>, <strong>top</strong> – задают положение окна на экране;</p>
<p><strong>[x] location</strong>, <strong>menubar</strong>, <strong>toolbar</strong>, <strong>status</strong>, <strong>titlebar</strong>, <strong>scrollbars</strong> – эти параметры выводят/скрывают свои соответствующие "панели" на окне. Задайте <strong>yes</strong>, чтобы вывести соответствующую "панель";</p>
<p><strong>[x] resizable</strong> – если задан как <strong>yes</strong>, то размер окна можно изменять.</p>
<p>Полное описание <strong>window.open</strong> можно увидеть в документации Mozilla.</p>
<p>Так как мы открываем пустое окно, то первый аргумент будет пустым. Для открытия страницы <strong>'test.html'</strong> вызов выглядел бы следующим образом: <strong>window.open ('test.html', 'TestWindow', 'width=200,height=200')</strong>.</p>
<p>В этом примере для объекта <strong>window</strong>, открываемого окна, задается переменная <strong>newWindow</strong>. В связи с этим для вывода содержимого в окне необходимо использовать <strong>newWindow.document.write</strong>.</p>
<p>Функция <strong>window.open</strong> также имеет свою противоположность, функцию <strong>window.close</strong>. Однако эта функция может успешно вызываться только на окнах, созданных <strong>JavaScript</strong>. Если попробовать закрыть окно, созданное не <strong>JavaScript</strong>, то возможны два варианта: либо появится сообщение, говорящее, что сценарий пытается закрыть окно, либо браузер просто это проигнорирует.</p>
<p>Можно видеть, что в этом примере используется еще одна новая функция <strong>setTimeout</strong>. Функции <strong>setTimeout</strong> и <strong>setInterval</strong> применяются для выполнения кода после указанного интервала времени и обе получают два аргумента: функцию или строку кода и период ожидания в мс. <strong>1 мс = 1/1000 секунды</strong>, поэтому для задания выполнения кода через <strong>5</strong> секунд необходимо определить в этом случае для второго аргумента значение <strong>5000</strong>.</p>
<p><strong>setTimeout</strong> выполнит код один раз после завершения заданного интервала времени. <strong>setInterval</strong> будет продолжать выполнять код после завершения каждого интервала. При заданном интервале <strong>5000 setInterval</strong> будет выполнять код каждые <strong>5</strong> секунд.</p>
<p>Существуют еще две другие функции: <strong>clearTimeout</strong> и <strong>clearInterval</strong>, которые отменяют выполнение, через заданные интервалы. Однако для этого необходимо иметь ссылку на вызов <strong>setTimeout</strong> или <strong>setInterval</strong>, например:</p>
<empty-line/>
<p><code>var myTimeout = setTimeout("alert('Hi!');", 500);</code></p>
<p><code>clearTimeout(myTimeout);</code></p>
<empty-line/>
<p>Если не сохранить ссылку в переменной <strong>myTimeout</strong>, то не существует способа отменить заданное выполнение. Давайте посмотрим на пример этого в действии:</p>
<empty-line/>
<p><code>function createTimeout(text, time){</code></p>
<p><code>setTimeout("alert('"+text+"');", time);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var intervals = [];</code></p>
<p><code>function createInterval(text, time){</code></p>
<p><code>// сохраняет интервал в массиве intervals</code></p>
<p><code>intervals.push(setInterval("alert('"+text+"');", time));</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function tut5(){</code></p>
<p><code>if(intervals.length==0) return;</code></p>
<p><code>// удаляет последний интервал выполнения в массиве intervals</code></p>
<p><code>clearInterval(intervals.pop());</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>Демонстрация в действии</code></p>
<empty-line/>
<p><code>Текст для вывода:</code></p>
<empty-line/>
<p><code>Время ожидания(в мс):</code></p>
<empty-line/>
<p><code>setTimeout</code></p>
<p><code>setInterval</code></p>
<p><code>clearInterval</code></p>
<empty-line/>
<p>Существует также функция <strong>clearTimeout</strong>, которая идентична по синтаксису <strong>clearInterval</strong>.</p>
<p>Важно отметить, что во время ожидания выполнения заданного кода функциями <strong>setTimeout</strong> или <strong>setInterval</strong> весь остальной код <strong>JavaScript</strong> продолжает выполняться. Когда функция <strong>setTimeout</strong> или <strong>setInterval</strong> будет готова, она выполнит заданный код, но только после того, как другой код закончит выполнение. Другими словами, <strong>setTimeout</strong> и <strong>setInterval</strong> никогда не прерывают для выполнения другой код.</p>
<p>Как говорилось ранее, свойство окна <strong>'opener'</strong> можно использовать для доступа к окну, которое открыло текущее окно, а также к любым свойствам, функциям и т.д. этого окна. Например:</p>
<empty-line/>
<p><code>&lt;!--page1.html--&gt;</code></p>
<p><code>&lt;HTML&gt;</code></p>
<p><code>&lt;HEAD&gt;</code></p>
<p><code>&lt;script type="text/javascript"&gt;</code></p>
<p><code>window.open('page2.html', 'TestWindow', 'width=500,height=200,resizable=yes');</code></p>
<p><code>&lt;/script&gt;</code></p>
<p><code>&lt;/HEAD&gt;</code></p>
<p><code>&lt;/HTML&gt;</code></p>
<empty-line/>
<p><code>&lt;!--page2.html--&gt;</code></p>
<p><code>&lt;HTML&gt;</code></p>
<p><code>&lt;HEAD&gt;</code></p>
<p><code>&lt;script type="text/javascript"&gt;</code></p>
<p><code>document.write('URL окна предка будет : '+window.opener.location);</code></p>
<p><code>&lt;/script&gt;</code></p>
<p><code>&lt;/HEAD&gt;</code></p>
<p><code>&lt;/HTML&gt;</code></p>
<empty-line/>
<p>Отметим, что это работает, только если <strong>URL</strong> открываемого окна находится на том же сервере, что и текущая страница. Если необходимо открыть, например, окно на <a l:href="http://www.webreference.com/">http://www.webreference.com</a>, то мы не получим доступ к свойствам этого окна. Это поддерживается всеми основными браузерами по соображениям безопасности.</p>
<p>Одной из наиболее часто используемых функций в <strong>JavaScript</strong> является <strong>document.write</strong>. Можно сказать, что <strong>document.write</strong> получает строку и выводит ее на странице. Здесь необходимо только следить за одной вещью. Если страница полностью загрузилась и вызывается <strong>document.write</strong>, то вся страница будет очищена и на экране будет только результат работы <strong>document.write</strong>.</p>
<p>Мы уже видели различные свойства объекта <strong>document</strong> в действии. Например, <strong>document.forms</strong> возвращает массив всех форм на странице. Здесь также существует несколько свойств, подобных этому.</p>
<p><strong>[x] document.forms</strong> – массив, содержащий все формы на текущей странице;</p>
<p><strong>[x] document.images</strong> – массив, содержащий все изображения на текущей странице;</p>
<p><strong>[x] document.links</strong> – массив, содержащий все ссылки на текущей странице;</p>
<p><strong>[x] document.anchors</strong> – массив, содержащий все анкеры на текущей странице;</p>
<p><strong>[x] document.applets</strong> – массив, содержащий все апплеты на текущей странице;</p>
<p><strong>[x] document.styleSheets</strong> – массив, содержащий все таблицы стилей на текущей странице;</p>
<p><strong>[x] window.frames</strong> – массив, содержащий все фреймы на текущей странице.</p>
<p>Как мы видели в предыдущей лекции, почти все эти свойства можно продублировать с помощью <strong>document.getElementsByTagName</strong>. Чтобы получить все изображения на странице, можно воспользоваться, например, <strong>document.getElementsByTagName('IMG');</strong>. Существует три подобные функции:</p>
<p><strong>[x] document.getElementById</strong> – возвращает один элемент на основе его <strong>ID</strong>;</p>
<p><strong>[x] document.getElementsByName</strong> – возвращает массив элементов, определенных по имени. В отличие от <strong>ID</strong> многие элементы могут иметь на странице одинаковые имена;</p>
<p><strong>[x] document.getElementsByTagName</strong> – возвращает массив элементов, определенных по имени тега. Имя тега является просто именем тега <strong>HTML</strong>, т.е. <strong>'DIV'</strong>, <strong>'IMG'</strong>, <strong>'TABLE'</strong>, <strong>'A '</strong>и т.д.</p>
<p>Существует еще одно свойство, <strong>document.all</strong>, которое выдает массив всех элементов на странице. Однако <strong>document.all</strong> поддерживается не всеми браузерами, поэтому предполагается, что вместо этого используется функция <strong>document.getElementsByTagName('*')</strong>, которая также вернет все элементы на странице.</p>
<p><strong>document.body</strong> ссылается на тег <strong>&lt;BODY&gt;</strong>, где должен предположительно находится весь контент. Весь <strong>DOM</strong> сайта вложен в <strong>document.body</strong>. Кроме этого, необходимо использовать <strong>document.body</strong> для определения, что документ был прокручен, и для получения размера окна. К сожалению, это является одной из наиболее сложных вещей, применяемых сегодня в Web-браузерах.</p>
<p>Существует концепция, называемая "Тип документа", которая задает для Web-браузера определенный набор правил. Изменение типа документа заставляет некоторые свойства переместиться из <strong>document.body</strong> в <strong>document.documentElement</strong>, но только некоторые свойства и только для некоторых браузеров.</p>
<p>Проще говоря, это является полным беспорядком, поэтому две следующие функции (будем надеяться) выдадут позицию прокручивания и размеры окна независимо от браузера.</p>
<empty-line/>
<p><code>function getScrollPos(){</code></p>
<p><code>if (window.pageYOffset){</code></p>
<p><code>return {y:window.pageYOffset, x:window.pageXOffset};</code></p>
<p><code>}</code></p>
<p><code>if(document.documentElement &amp;&amp; document.documentElement.scrollTop){</code></p>
<p><code>return {y:document.documentElement.scrollTop, x:document.documentElement.scrollLeft};</code></p>
<p><code>}</code></p>
<p><code>if(document.body){</code></p>
<p><code>return {y:document.body.scrollTop, x:document.body.scrollLeft};</code></p>
<p><code>}</code></p>
<p><code>return {x:0, y:0};</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function getWindowDims(){</code></p>
<p><code>if (window.innerWidth){</code></p>
<p><code>return {w:window.innerWidth, h:window.innerHeight};</code></p>
<p><code>}</code></p>
<p><code>if (document.documentElement &amp;&amp; document.documentElement.clientWidth){</code></p>
<p><code>return {w:document.documentElement.clientWidth, h:document.documentElement.cliendHeight};</code></p>
<p><code>}</code></p>
<p><code>if (document.body){</code></p>
<p><code>return {w:document.body.clientWidth, h:document.body.clientHeight};</code></p>
<p><code>}</code></p>
<p><code>return {w:0, h:0}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Тремя последними свойствами документа являются <strong>title</strong>, <strong>referer</strong> и <strong>cookies</strong>. <strong>document.title</strong> и <strong>document.referer</strong> достаточно понятны. <strong>document.title</strong> содержит заголовок страницы. Его можно прочитать и изменить после полной загрузки документа. <strong>document.referer</strong> содержит просто <strong>URL</strong> страницы, которая привела пользователя на текущую страницу.</p>
<p>Поэтому, если вы щелкнули на ссылке, чтобы попасть на эту страницу, то <strong>document.referer</strong> будет содержать <strong>URL</strong> страницы, на которой находится ссылка. Если вы пришли на эту страницу сразу, задавая ее в поле адреса браузера, то <strong>document.referer</strong> будет не определен.</p>
<p>Последняя тема этой лекции, переменная <strong>cookie</strong>, отличается от всего остального в <strong>JavaScript</strong>. <strong>cookie</strong> является строкой текста, которую можно сохранить с одной страницы на другой, если вы находитесь на одном и том же сервере. В отличие от других переменных в <strong>JavaScript</strong>, <strong>cookie</strong> не стирается при перезагрузке страницы. <strong>cookie</strong> стираются только через определенный период времени или когда все <strong>cookie</strong> удаляются в браузере.</p>
<p><strong>cookie</strong> читают и записывают через <strong>document.cookie</strong>. В отличие от других свойств изменение <strong>document.cookie</strong> в действительности не перезаписывает, а добавляет к <strong>cookie</strong>. Поэтому, если требуется задать <strong>5 cookie</strong>, то каждое из них задается с помощью <strong>document.cookie="...";</strong>. Формат <strong>cookie</strong> имеет свои особенности, поэтому мы рассмотрим несколько функций для выполнения этой задачи:</p>
<empty-line/>
<p><code>function writeCookie(name, value, days){</code></p>
<p><code>if(days){</code></p>
<p><code>(time = new Date()).setTime(new Date().getTime()+days*24*60*60*1000);</code></p>
<p><code>var exp = '; expires='+time.toGMTString();</code></p>
<p><code>}else{</code></p>
<p><code>var exp='';</code></p>
<p><code>}</code></p>
<p><code>document.cookie=name+"="+value+exp+"; path=/";</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function readCookie(name){</code></p>
<p><code>var cookies = document.cookie.split(';');</code></p>
<p><code>for(var i=0; i&lt;cookies.length; i++){</code></p>
<p><code>var cookie=cookies[i].replace(/^\s+/, '');</code></p>
<p><code>if (cookie.indexOf(name+'=')==0) return cookie.substring(name.length+1);</code></p>
<p><code>}</code></p>
<p><code>return null;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function eraseCookie(name){</code></p>
<p><code>writeCookie(name, "", -1);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Три эти функции выполняют запись, чтение и стирание <strong>cookie</strong> на текущей странице. Их можно протестировать с помощью следующего кода:</p>
<empty-line/>
<p><code>function addToCounter(){</code></p>
<p><code>var counter = readCookie('myCounter');</code></p>
<p><code>if(counter){</code></p>
<p><code>counter = parseInt(counter);</code></p>
<p><code>} else {</code></p>
<p><code>counter = 0;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>writeCookie('myCounter', counter+1, 1);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function showCounter(){</code></p>
<p><code>alert(readCookie('myCounter'));</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Если увеличить счетчик <strong>cookie</strong> несколько раз, обновить страницу, а затем проверить счетчик, то можно увидеть, что он остался таким же, как был до обновления страницы. Эти <strong>cookie</strong> будут сохранятся до тех пор, пока они не будут удалены из браузера или пока не пройдет 24 часа – <strong>cookie</strong> заданы на период одни сутки.</p>
<p>Это почти все об объектах окна и документа. В следующей лекции речь пойдет об объектно-ориентированном коде.</p>
</section>
<section>
<title>
<p><emphasis>Лекция 8.</emphasis> Основы объектно-ориентированного программирования</p>
</title>
<p><emphasis>Основы объектно-ориентированного программирования (ООП) в JavaScript. new Object и объектные литералы. Прототипирование. Переменные Private, Public и Static.</emphasis></p>
<p>Почти каждый современный язык программирования имеет некоторый метод записи объектно-ориентированного (ОО) кода. Если вы знакомы с такими языками, как <strong>C++</strong>, <strong>Java</strong>, <strong>VB</strong>, <strong>php</strong> или подобными, то должны быть знакомы и со структурой <strong>Class</strong> этих языков.</p>
<p>Классы в этих языках позволяют быстро создавать объекты с одинаковыми свойствами и методами, не требуя при этом заново определять все эти свойства и методы. В терминах структур мы имеем классы, а внутри этих классов – функции и переменные, а внутри каждой из этих функций – дополнительные переменные. Каждая функция в классе идеально работает с переменными и другими функциями, внутренними для этого класса.</p>
<p>Структура <strong>Class</strong> и объекты в целом хорошо работают потому, что они действуют как реальные объекты. Например, мы можем иметь класс <strong>Телевизор</strong>. Так как все телевизоры в целом работают одинаково, то нет необходимости переопределять множество атрибутов телевизора, чтобы сделать еще один новый. Этот класс будет определять методы и свойства телевизора. Мы будем иметь такие свойства, как марка, размер экрана, и т.д., и методы, такие, как включить/выключить, сменить канал, и т.д.</p>
<p><strong>JavaScript</strong> слегка отличается от стандартной объектно-ориентированной структуры <strong>Class</strong>. Вместо использования классов для создания объектов, каждая функция в <strong>JavaScript</strong> может эффективно действовать как класс. Мы используем концепцию вложенных функций, называемую прототипированием (<strong>Prototyping</strong>), для выполнения таких же вещей, как и языки со структурами <strong>Class</strong>. Если вы знакомы с ОО-языком на основе классов, то прототипирование может показаться сначала непривычной концепцией, но она предлагает большие возможности и часто является значительно более гибкой с точки зрения программирования, чем другие методы.</p>
<p>Для начала необходимо объяснить, как объекты действуют в <strong>JavaScript</strong>. Объекты позволяют определить переменную и задать затем для этой переменной любое число свойств. Чтобы понять это, давайте посмотрим на простой пример:</p>
<empty-line/>
<p><code>var myObj = new Object;</code></p>
<p><code>myObj.a = 5;</code></p>
<p><code>myObj['b'] = 10;</code></p>
<p><code>myObj.c = 20;</code></p>
<p><code>myObj.getTotal = function(){</code></p>
<p><code>alert(this.a+this.b+this.c);</code></p>
<p><code>};</code></p>
<empty-line/>
<p><code>// или</code></p>
<empty-line/>
<p><code>var myObj = {a:5, b:10, c:20,</code></p>
<p><code>getTotal:function() { alert(this.a+this.b+this.c); }};</code></p>
<empty-line/>
<p>Оба эти фрагмента кода создают одну и ту же переменную <strong>myObj</strong>. Первый пример использует синтаксис <strong>new Object()</strong>, а затем определяет все свойства одно за другим. Второй фрагмент кода является сокращенной нотацией, которая делает в точности то же самое. Мы имеем теперь переменную <strong>myObj</strong>. <strong>myObj</strong> содержит три переменные для целых чисел: <strong>a</strong>, <strong>b</strong> и <strong>c</strong>. Для доступа к любой из них мы просто используем <strong>myObj.a</strong> или <strong>myObj['a']</strong>. Можно видеть, что <strong>myObj</strong> имеет также в качестве свойства функцию <strong>getTotal</strong>. Мы обращаемся к <strong>getTotal</strong> таким же образом, как и к свойствам <strong>a</strong>, <strong>b</strong> и <strong>c</strong>: <strong>myObj.getTotal()</strong>. Функция <strong>getTotal()</strong> обращается к переменным в переменной <strong>myObj</strong> с помощью <strong>this</strong>. При выполнении кода внутри функции в объекте <strong>this</strong> ссылается на объект. В данном случае <strong>this</strong> ссылается на сам объект <strong>myObj</strong>.</p>
<p>Как можно видеть, объекты в <strong>JavaScript</strong> являются чрезвычайно полезными. К сожалению, часто приходится объявлять слишком много информации каждый раз, когда мы хотим создать объект. Например, давайте создадим объект <strong>Animal</strong>:</p>
<empty-line/>
<p><code>var myAnimal = {</code></p>
<p><code>name: 'felix',</code></p>
<p><code>species: 'cat',</code></p>
<p><code>talk: function(){ alert('Meow!'); },</code></p>
<p><code>callOver: function(){ alert(this.name+' ignores you'); },</code></p>
<p><code>pet: function(){ alert('Purr!'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Мы имеем переменную <strong>myAnimal</strong>, которая представляет кота (<strong>cat</strong>) с именем <strong>Феликс</strong> (<strong>felix</strong>). Однако, если потребуется создать другого кота, нам понадобиться ввести все это снова. Здесь на помощь приходит объектно-ориентированный подход. Вместо перепечатки всякий раз всего объекта можно определить функцию, которая создает для нас аналогичный объект:</p>
<empty-line/>
<p><code>function Cat(name){</code></p>
<p><code>this.name = name;</code></p>
<empty-line/>
<p><code>this.species = 'Cat';</code></p>
<p><code>this.talk = function(){ alert('Meow!'); }</code></p>
<p><code>this.callOver = function(){ alert(this.name+' ignores you'); },</code></p>
<p><code>this.pet = function(){ alert('Purr!'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var felix = new Cat('Felix');</code></p>
<p><code>var sam = new Cat('Sam');</code></p>
<p><code>var patty = new Cat('Patty');</code></p>
<empty-line/>
<p><code>felix.pet(); // выводит 'Purr!'</code></p>
<p><code>sam.callOver(); // выводит 'Sam ignores you'. Просто, как кот!</code></p>
<p><code>alert(patty.species); // выводит 'Cat'</code></p>
<empty-line/>
<p>В этом примере создана одна функция <strong>Cat</strong>, а затем создаются три новых кота с помощью этой функции: <strong>Felix</strong>, <strong>Sam</strong> и <strong>Patty</strong>. Каждый из этих котов имеет одинаковые функции: <strong>talk</strong>, <strong>callOver</strong> и <strong>pet</strong>, и каждая из них имеет свойство <strong>species</strong>, заданное как <strong>'cat'</strong>. И подобно всем котам, они в равной степени своенравны.</p>
<p>Обычно говорят, что <strong>felix</strong>, <strong>sam</strong> и <strong>patty</strong> являются экземплярами одного объекта: <strong>Cat</strong>. Код самой функции <strong>Cat</strong> называется конструктором. Мы передаем ей переменную <strong>name</strong> и используем ее для задания <strong>this.name</strong>. К сожалению, при объявлении каждой функции <strong>Cat</strong> в конструкторе в действительности создается новая копия каждой функции всякий раз при создании нового <strong>Cat</strong>. Так как функции <strong>talk</strong>, <strong>callOver</strong> и <strong>pet</strong> являются идентичными, то нам в действительности требуется только одна копия каждой функции. Здесь на помощь приходит прототипирование.</p>
<p>Можно переписать функцию <strong>Cat</strong> таким образом, чтобы каждая функция объявлялась только один раз:</p>
<empty-line/>
<p><code>function Cat(name){</code></p>
<p><code>this.name = name;</code></p>
<p><code>}</code></p>
<p><code>Cat.prototype.species = 'Cat';</code></p>
<p><code>Cat.prototype.talk = function(){ alert('Meow!'); };</code></p>
<p><code>Cat.prototype.callOver = function(){ alert(this.name+' ignores you'); };</code></p>
<p><code>Cat.prototype.pet = function(){ alert('Purr!'); };</code></p>
<empty-line/>
<p>Синтаксис этого метода немного отличается от предыдущего. Вместо объявления всех свойств и методов внутри функции <strong>Cat</strong>, они теперь объявляются с помощью <strong>Cat.prototype</strong>. Это может показаться более сложным, но предлагает много преимуществ. Предположим, например, что надо добавить новую функцию <strong>sleep</strong> для каждого имеющегося <strong>cat</strong>. Это можно сделать двумя способами. Первый: можно добавить функцию <strong>sleep</strong> в <strong>felix</strong>, <strong>sam</strong> и <strong>patty</strong>. Это, однако, не только трудоемко, но также и неэффективно. Если бы имелось <strong>500 cat</strong>, то потребовалось бы сначала отследить всех этих <strong>500</strong> котов, а затем добавить функцию каждому <strong>cat</strong>.</p>
<p>Однако с помощью прототипов можно добавить функцию <strong>sleep</strong> всем <strong>cat</strong> одновременно:</p>
<empty-line/>
<p><code>Cat.prototype.sleep = function(){ alert(this.name+' falls asleep'); };</code></p>
<empty-line/>
<p>Этот способ не только быстрее, но к тому же нам больше не требуется отслеживать каждого <strong>cat</strong>, чтобы добавить функцию <strong>sleep</strong>.</p>
<p>Существует более быстрый способ добавления прототипов. С помощью объектного литерала можно одновременно задать любое количество прототипов свойств или методов.</p>
<empty-line/>
<p><code>function Cat(name){</code></p>
<p><code>this.name = name;</code></p>
<p><code>}</code></p>
<p><code>Cat.prototype = {</code></p>
<p><code>species: 'Cat',</code></p>
<p><code>talk: function(){ alert('Meow!'); },</code></p>
<p><code>callOver: function(){ alert(this.name+' ignores you'); },</code></p>
<p><code>pet: function(){ alert('Pet!'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Важно отметить, что с помощью этого метода можно задать свойства функции только один раз. После этого необходимо использовать предыдущий метод.</p>
<empty-line/>
<p><code>Object.prototype.method = function(){ ... }.</code></p>
<empty-line/>
<p>Если попробовать теперь добавить в <strong>cat</strong> метод <strong>sleep</strong> с помощью этого метода:</p>
<empty-line/>
<p><code>Cat.prototype = {</code></p>
<p><code>sleep: function(){ alert(this.name+' falls asleep'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p>то предыдущие прототипы, <strong>species</strong>, <strong>talk</strong>, <strong>callOver</strong> и <strong>pet</strong>, будут все удалены. Единственным имеющимся прототипом для <strong>cat</strong> будет <strong>sleep</strong>.</p>
<p>Прототипы можно также использовать для расширения встроенных объектов <strong>JavaScript</strong>. Можно реализовать, например, функцию <strong>String.prototype.reverse</strong>, которая будет возвращать любую созданную строку в обратном порядке:</p>
<empty-line/>
<p><code>String.prototype.reverse = function(){</code></p>
<p><code>var out = '';</code></p>
<p><code>for(var i=this.length-1; i&gt;=0; i--){</code></p>
<p><code>out+=this.substr(i, 1);</code></p>
<p><code>}</code></p>
<p><code>return out;</code></p>
<p><code>}</code></p>
<p><code>alert('asdf'.reverse());</code></p>
<empty-line/>
<p>Это может быть очень полезным инструментом при правильном использовании. Можно реализовать <strong>String.prototype.trim()</strong> для удаления из строки всех пробелов, <strong>Date.prototype.dayName</strong> – для получения названия дня недели из объекта <strong>Date</strong> и т.д. Однако настоятельно рекомендуется воздержаться от добавления каких-либо прототипов в <strong>Array</strong> или <strong>Object</strong>, так как в этом случае циклы <strong>for-in</strong> для двух этих типов данных будут работать неправильно. Рассмотрим следующий пример:</p>
<empty-line/>
<p><code>var myArray = [1, 2, 3];</code></p>
<p><code>for(n in myArray) alert(n); // выводит 0, 1 и 2 – индексы массива.</code></p>
<empty-line/>
<p><code>Array.prototype.something = function(){ };</code></p>
<empty-line/>
<p><code>for(n in myArray) alert(n); // выводит 'something', 0, 1 и 2.</code></p>
<empty-line/>
<p>Как можно видеть, здесь выполнено прототипирование <strong>Array</strong> и добавлена функция <strong>something</strong>. Однако теперь эта функция <strong>something</strong> видна как элемент массива, результат, который определенно не ожидался и не требовался. То же самое происходит с объектами и объектными литералами, если выполнить прототипирование <strong>Object</strong>. Если можно быть абсолютно уверенным, что цикл <strong>for-in</strong> никогда не будет использоваться и никакой другой разработчик не будет использовать этот код <strong>JavaScript</strong>, то можно применять прототипирование для <strong>Array</strong> или <strong>Object</strong>, но надо помнить о связанных с этим проблемах. Однако существуют другие методы для достижения тех же результатов. Например, для расширения <strong>Array</strong> можно задействовать следующий метод без прототипирования:</p>
<empty-line/>
<p><code>Array.find = function(ary, element){</code></p>
<p><code>for(var i=0; i&lt;ary.length; i++){</code></p>
<p><code>if(ary[i] == element){</code></p>
<p><code>return i;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>return -1;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>alert(Array.find(['a', 'b', 'c', 'd', 'e'], 'b')); // выводит 1</code></p>
<empty-line/>
<p>Как можно видеть, теперь необходимо печатать <strong>Array.find(ary, e)</strong> вместо <strong>ary.find(e)</strong>, что пришлось бы делать, если прототипировать объект <strong>Array</strong>, но стоит напечатать эти несколько дополнительных символов, чтобы избежать потери существующей функциональности <strong>JavaScript</strong>.</p>
<p>Способ определения переменных в объекте определяет, какие методы этого объекта можно использовать для доступа к этим переменным. В <strong>JavaScript</strong> при работе с объектно-ориентированным кодом используется пять уровней методов и свойств.</p>
<p><strong>1</strong> Скрытая (<strong>Private</strong>) – объявляется с помощью <strong>var variableName</strong> или <strong>function functionName</strong> внутри объекта. Могут быть доступны только другим скрытым или привилегированным функциям.</p>
<p><strong>2</strong> Открытая (<strong>Public</strong>) – объявляется с помощью <strong>this.variableName</strong> внутри объекта. Может изменяться любой функцией или методом.</p>
<p><strong>3</strong> Привилегированная (<strong>Privileged</strong>) – объявляется с помощью <strong>this.functionName = function(){ ... }</strong> внутри объекта. Доступна для любой функции или метода и может обращаться или изменять любую скрытую переменную.</p>
<p><strong>4</strong> Прототипированная (<strong>Prototype</strong>) – объявляется с помощью <strong>Class.prototype.variableName</strong> или <strong>Class.prototype.functionName</strong>. Объявленные таким образом функции будут иметь доступ к любой открытой или прототипированной функции. Попытки изменить созданную таким образом переменную будут вместо этого создавать новую открытую переменную на объекте, а прототипированная переменная будет недоступна.</p>
<p><strong>5</strong> Статическая (<strong>Static</strong>) – объявляется с помощью <strong>Class.variableName</strong> или <strong>Class.functionName</strong>. Может изменяться любой функцией или методом. Такой метод используется редко.</p>
<p>Чтобы понять различия между уровнями, давайте рассмотрим пример:</p>
<empty-line/>
<p><code>function Cat(name, color){</code></p>
<p><code>/*</code></p>
<p><code>Конструктор: при создании объекта выполняется любой находящийся здесь код</code></p>
<p><code>*/</code></p>
<p><code>Cat.cats++;</code></p>
<empty-line/>
<p><code>/* Скрытые переменные и функции доступны только скрытым или привилегированным</code></p>
<p><code>функциям. Отметим, что 'name' и 'color', переданные в Class, уже являются</code></p>
<p><code>скрытыми переменными.</code></p>
<p><code>*/</code></p>
<empty-line/>
<p><code>var age = 0;</code></p>
<p><code>var legs = 4;</code></p>
<p><code>function growOlder(){</code></p>
<p><code>age++;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>/*</code></p>
<p><code>Открытые переменные доступны открыто или скрыто</code></p>
<p><code>*/</code></p>
<empty-line/>
<p><code>this.weight = 1;</code></p>
<p><code>this.length = 5;</code></p>
<empty-line/>
<p><code>/*</code></p>
<p><code>Привилегированные функции доступны открыто или скрыто.</code></p>
<p><code>Могут обращаться к скрытым переменным.</code></p>
<empty-line/>
<p><code>Невозможно изменить, можно только заменить открытой версией</code></p>
<p><code>*/</code></p>
<empty-line/>
<p><code>this.age = function(){</code></p>
<p><code>if(age==0) this.length+=20;</code></p>
<empty-line/>
<p><code>growOlder();</code></p>
<p><code>this.weight++;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>/*</code></p>
<p><code>Прототипированные функции доступны открыто</code></p>
<p><code>*/</code></p>
<p><code>Cat.prototype = {</code></p>
<p><code>talk: function(){ alert('Meow!'); },</code></p>
<p><code>callOver: function(){ alert(this.name+' ignores you'); },</code></p>
<p><code>pet: function(){ alert('Pet!'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>/*</code></p>
<p><code>Прототипированные переменные доступны открыто.</code></p>
<p><code>Нельзя перезаписать, только заменить открытой версией</code></p>
<p><code>*/</code></p>
<empty-line/>
<p><code>Cat.prototype.species = 'Cat';</code></p>
<empty-line/>
<p><code>/*</code></p>
<p><code>Статические переменные и функции доступны открыто</code></p>
<p><code>*/</code></p>
<empty-line/>
<p><code>Cat.cats = 0;</code></p>
<empty-line/>
<p>Мы видим, что существует несколько уровней доступа. Как было сказано ранее, все скрытые, привилегированные и открытые функции и переменные копируются всякий раз, когда создается новый экземпляр объекта. Обычно почти все, что нужно сделать, можно реализовать с помощью прототипированных и открытых переменных. В связи с этим обычно лучше избегать использования скрытых, привилегированных и статических переменных, если это не требуется специально.</p>
</section>
<section>
<title>
<p><emphasis>Лекция 9.</emphasis> Наследование и замыкание</p>
</title>
<p><emphasis>Метод наследования. Полезные (и опасные) свойства замыкания.</emphasis></p>
<p>В восьмой лекции были рассмотрены основы объектно-ориентированного программирования в <strong>JavaScript</strong>. В данной лекции эта тема будет продолжена рассмотрением методов наследования, а также полезных (и опасных) свойств замыкания.</p>
<p>В предыдущей лекции была создана функция <strong>'Cat'</strong> :</p>
<empty-line/>
<p><code>function Cat(name){</code></p>
<p><code>this.name = name;</code></p>
<p><code>}</code></p>
<p><code>Cat.prototype = {</code></p>
<p><code>species: 'Cat',</code></p>
<p><code>talk: function(){ alert('Meow!'); },</code></p>
<p><code>callOver: function(){ alert(this.name+' ignores you'); },</code></p>
<p><code>pet: function(){ alert('Pet!'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Теперь можно создать любое количество котов, но как быть, если мы захотим создать объект другого типа, например, собаку? В этом случае понадобится создать совершенно новую функцию, со своими собственными прототипами. Если два объекта используют одни и те же функции (например, можно было бы добавить функции <strong>sleep</strong> (спать), <strong>eat</strong> (есть), и <strong>play</strong> (играть)), то в результате мы бы имели чрезмерное дублирование кода. Решением является концепция наследования.</p>
<p>По сути наследование позволяет определить объекты "предки" и "потомки". Потомок наследует все свойства своего предка. Можно было создать, например, функцию <strong>Animal</strong>, <strong>Pet</strong> или <strong>Mammal</strong>. Обе функции <strong>Cat</strong> и <strong>Dog</strong> обладали бы многими свойствами функции предка <strong>Animal</strong>, и нам пришлось бы писать этот код один раз.</p>
<p>Проблема в том, что <strong>JavaScript</strong> не имеет в действительности встроенного механизма наследования, поэтому эту функциональность необходимо создавать самостоятельно. Для этого существует несколько различных способов. Один из них состоит в использовании функции <strong>call</strong>. Эта функция позволяет вызывать одну функцию из контекста другой, т.е. мы можем определить, как действует ключевое слово <strong>this</strong>. С помощью <strong>call</strong> можно написать класс <strong>Animal</strong> (Животное), а затем вызвать его из класса <strong>Cat</strong> или <strong>Dog</strong>.</p>
<empty-line/>
<p><code>function Animal(name){</code></p>
<p><code>this.name = name;</code></p>
<empty-line/>
<p><code>this.species = 'Animal';</code></p>
<p><code>this.sleep = function(){ alert(this.name+' спит: Хрррр'); }</code></p>
<p><code>}</code></p>
<p><code>function Cat(name){</code></p>
<p><code>Animal.call(this, name);</code></p>
<empty-line/>
<p><code>this.talk = function(){ alert('Мяу!'); }</code></p>
<p><code>}</code></p>
<p><code>function Dog(name){</code></p>
<p><code>Animal.call(this, name);</code></p>
<empty-line/>
<p><code>this.talk = function(){ alert('Гав!'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var sam = new Cat('Sam');</code></p>
<p><code>var joe = new Dog('Joe');</code></p>
<p><code>sam.sleep(); // Sam спит: Хрррр</code></p>
<p><code>joe.sleep(); // Joe спит: Хрррр</code></p>
<empty-line/>
<p><code>sam.talk(); // Мяу!</code></p>
<p><code>joe.talk(); // Гав!</code></p>
<empty-line/>
<p>Хотя это работает, мы немного ограничены в своих возможностях. Например, прототипирование не действует при использовании этого метода: все прототипы, заданные на <strong>Animal</strong>, не будут переноситься в функции <strong>Cat</strong> или <strong>Dog</strong>. Как мы знаем из предыдущей лекции, определенные внутренне с помощью "<strong>this.</strong>" функции создают новый экземпляр всякий раз при создании новой копии предка. В этом случае всякий раз при создании функции <strong>Animal</strong>, <strong>Cat</strong> или <strong>Dog</strong> появляется новая копия функций <strong>species</strong> и <strong>sleep</strong>. Как можно догадаться, это не самый эффективный способ.</p>
<p>Лучшим подходом является прототипирование всего родительского класса на классе-потомке. Это предоставляет доступ ко всем свойствам и методам класса предка:</p>
<empty-line/>
<p><code>function Animal(name){</code></p>
<p><code>this.name = name;</code></p>
<p><code>}</code></p>
<p><code>Animal.prototype = {</code></p>
<p><code>species: 'Animal',</code></p>
<p><code>sleep : function(){ alert(this.name+' спит: Хрррр'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function Cat(name){</code></p>
<p><code>Animal.apply(this, arguments);</code></p>
<p><code>}</code></p>
<p><code>Cat.prototype = new Animal;</code></p>
<p><code>Cat.prototype.species = 'Cat';</code></p>
<p><code>Cat.prototype.talk = function(){ alert('Мяу!'); }</code></p>
<empty-line/>
<p><code>function Dog(name){</code></p>
<p><code>Animal.apply(this, arguments);</code></p>
<p><code>}</code></p>
<p><code>Dog.prototype = new Animal;</code></p>
<p><code>Dog.prototype.talk = function(){ alert('Гав!'); }</code></p>
<empty-line/>
<p><code>var sam = new Cat('Sam');</code></p>
<p><code>var joe = new Dog('Joe');</code></p>
<empty-line/>
<p><code>sam.sleep(); // Sam спит : Хрррр</code></p>
<p><code>joe.sleep(); // Joe спит: Хрррр</code></p>
<empty-line/>
<p><code>alert(sam.species); // Cat</code></p>
<p><code>alert(joe.species); // Animal – для Dog функция species не определена</code></p>
<empty-line/>
<p>Можно продолжить это дальше и создать отдельные функции для различных пород собак или кошек и т.д.</p>
<p>Замыкание (<strong>сlosure</strong>) является одним из наиболее мощных средств <strong>JavaScript</strong>. Если воспользоваться простым объяснением, то замыкание связывает внутренние и внешние переменные в функции. Почему это так важно? Потому что замыкание позволяет эмулировать почти любое свойство любого языка программирования, даже если оно не существует в <strong>JavaScript</strong>. Это звучит немного непонятно, поэтому лучше начать с более простого примера:</p>
<empty-line/>
<p><code>function beginAdding(a){</code></p>
<p><code>a *= 5;</code></p>
<p><code>return function finishAdding(b){ alert(a+b); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var add = beginAdding(10);</code></p>
<empty-line/>
<p><code>add(20); // 70</code></p>
<empty-line/>
<p>Можно видеть, что в приведенном коде переменной <strong>'a'</strong> присваивается значение <strong>10</strong> и передается в функцию <strong>beginAdding</strong>, в то время как переменной <strong>'b'</strong> присваивается значение <strong>20</strong> и передается в функцию <strong>finishAdding</strong>.</p>
<p>А что содержится в переменной <strong>'add'</strong>? Она содержит функцию <strong>finishAdding</strong> с копией связанной с ней всей функции <strong>beginAdding</strong>. Копия переменной <strong>'a'</strong> из <strong>beginAdding</strong> сохраняется в памяти для дальнейшего использования.</p>
<p>Теперь, имея представление о замыкании, прежде чем продолжать, необходимо обсудить проблему утечки памяти. <strong>Internet Explorer</strong>, в частности, подвержен достаточно неприятным утечкам памяти при использовании замыкания. Чтобы понять, почему необходимо знать о сборке мусора в <strong>Internet Explorer</strong>, посмотрим, как в этом браузере выполняется очистка памяти от ненужных объектов.</p>
<p><strong>Internet Explorer</strong> имеет два отдельных сборщика мусора: один для <strong>JavaScript</strong> и другой для объектов <strong>DOM</strong>. При выгрузке страницы браузер просматривает и удаляет весь код <strong>JavaScript</strong> и все объекты <strong>DOM</strong> со страницы. Утечка происходит, когда имеются циклические ссылки из объекта <strong>DOM</strong> в <strong>JavaScript</strong> и снова на объект <strong>DOM</strong> или из <strong>JavaScript--&gt;Dom--&gt;Javascript</strong>. <strong>Internet Explorer</strong> запутывается и не удаляет объекты при циклической ссылке.</p>
<empty-line/>
<p><code>var someInput = document.getElementById('inputbox');</code></p>
<p><code>var someFunction = function(){</code></p>
<p><code>alert(someInput.value);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>someInput.onclick = someFunction;</code></p>
<empty-line/>
<p>Здесь представлен бесконечный цикл в терминах замыканий. Объект <strong>DOM someInput</strong> вовлечен в замыкание с функцией <strong>someFunction</strong> и наоборот. Браузер не может определить, что удалить в первую очередь, поэтому в результате имеем утечку памяти.</p>
<p>Замыкания создают, часто даже не осознавая этого. Возьмем, например, простую функцию:</p>
<empty-line/>
<p><code>function Animal(name){</code></p>
<p><code>this.sleep = function(){ alert(name+' спит: Хрррр'); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Можно не заметить этого, но переменная <strong>'name'</strong> в функции <strong>sleep</strong> приходит из родительской функции <strong>Animal</strong>. Это создает замыкание.</p>
<p>Даже определение простейшей функции может создавать замыкание:</p>
<empty-line/>
<p><code>var x = 5;</code></p>
<p><code>var n = function(){</code></p>
<p><code>y=10;</code></p>
<p><code>return y;</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Здесь также создается замыкание, хотя на первый взгляд это не так. Почему? Когда мы создаем функцию, она получает доступ ко всем переменным в своей текущей области действия, поэтому мы создаем новую ссылку на переменную <strong>х</strong>.</p>
<p>Теперь мы подошли к понятию области действия. Каждая функция имеет свою область действия, в которой она выполняется. Все области действия кода сохраняются во внутреннем стеке памяти. Когда создается замыкание, оно получает доступ к одной из этих областей действия. Если создается несколько замыканий в одной и той же области действия, то каждое замыкание будет в действительности указывать на одинаковые копии каждой переменной области действия. Например:</p>
<empty-line/>
<p><code>var x = 5;</code></p>
<p><code>var alertX1 = function(){ alert(x); }</code></p>
<empty-line/>
<p><code>x = 10;</code></p>
<p><code>var alertX2 = function(){ alert(x); }</code></p>
<empty-line/>
<p><code>alertX1();</code></p>
<p><code>alertX2();</code></p>
<empty-line/>
<p>Обе функции в этом случае выведут <strong>10</strong>. Почему? Потому что они обе указывают на одну и ту же копию <strong>х</strong>.</p>
<empty-line/>
<image l:href="#scope1.png"/>
<empty-line/>
<p>Если изменить <strong>x</strong> в любой точке, то обе функции отразят это. Как это исправить? Проще всего изменить область действия замыкания:</p>
<empty-line/>
<p><code>function makeClosure(x){</code></p>
<p><code>return function(){ alert(x); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var x = 5;</code></p>
<p><code>var alertX1 = makeClosure(x);</code></p>
<empty-line/>
<p><code>x = 10;</code></p>
<p><code>var alertX2 = makeClosure(x);</code></p>
<empty-line/>
<p><code>alertX1(); // 5</code></p>
<p><code>alertX2(); // 10</code></p>
<empty-line/>
<p>Это решает проблему. Если, однако, этот код создавал утечку памяти, то утечка будет существенно больше, чем в предыдущем примере; и также используется больший объем памяти. Оказывается, что в действительности имеется три различных области действия в этом простом примере:</p>
<empty-line/>
<image l:href="#scope2.png"/>
<empty-line/>
<p>Можно видеть, что переменная <strong>х</strong> копируется в каждую из двух областей действия. Это связано с тем, что <strong>x</strong> является строкой или числом. JavaScript всегда передает строки и числа по значению – то есть всегда делается копия переменной. С объектами все происходит иначе. Если <strong>х</strong> является функцией, массивом или базовым объектом, то в этом случае ссылка в двух наших функциях происходит на одну и ту же копию <strong>x</strong> и поэтому в результате выводимое сообщение будет одинаковым:</p>
<empty-line/>
<p><code>function makeClosure(x){</code></p>
<p><code>return function(){ alert(x.val); }</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>var x = {val:5};</code></p>
<p><code>var alertX1 = makeClosure(x);</code></p>
<empty-line/>
<p><code>x.val = 10;</code></p>
<p><code>var alertX2 = makeClosure(x);</code></p>
<empty-line/>
<p><code>alertX1(); // 10</code></p>
<p><code>alertX2(); // 10</code></p>
<empty-line/>
<p>Отличие состоит в том, что <strong>x</strong> теперь является объектом. Каждая из дополнительных областей действия указывает на одну и ту же копию <strong>x</strong>. При изменении значения <strong>x</strong> оно изменяется в каждой области действия, в которой <strong>х</strong> упоминается.</p>
<p>Как избежать утечки памяти при использовании замыканий? Необходимо избегать использования циклических ссылок. Наиболее распространенной причиной утечки памяти является присоединение событий, таких, как событие <strong>onclick</strong>, к объектам <strong>DOM</strong>.</p>
<p>Часто совершенно невинный с виду код будет создавать утечку и ее бывает крайне сложно обнаружить. К счастью, протестировать наличие утечки памяти достаточно легко. Если при каждом обновлении страницы используемая память увеличивается, то приложение имеет утечку. Отследить, где это происходит, совершенно другая задача, но по крайней мере теперь известно о наличии проблемы!</p>
<p>Следующая лекция будет посвящен основам приложений <strong>AJAX</strong>!</p>
</section>
<section>
<title>
<p><emphasis>Лекция 10.</emphasis> Основы приложений AJAX</p>
</title>
<p><emphasis>Основы приложений AJAX. Создание объекта XMLHttp. Варианты получения данных: XML, JSON или обычный текст. Пример со списком контактов.</emphasis></p>
<p>В последнее время термин <strong>AJAX</strong> получил широкое распространение. По сути, это необычное название технологии, которая уже давно существует. Однако за последний год <strong>JavaScript</strong> в стиле <strong>AJAX</strong> стал очень популярным у многих разработчиков, и мы начинаем видеть, как с его помощью стали создавать различные интересные вещи. <strong>Google Maps</strong> и <strong>GMail</strong> являются двумя наиболее широко известными приложениями <strong>AJAX</strong>, но в последнее время и другие компании по всему миру начали использовать ее на своих сайтах.</p>
<p><strong>AJAX</strong> означает "<strong>Asynchronous JavaScript and XML</strong>", т.е. Асинхронный <strong>JavaScript</strong> и <strong>XML</strong>. В действительности <strong>AJAX</strong> состоит из <strong>JavaScript</strong>, как и любое другое приложение, и соединения <strong>XMLHTTP</strong> с <strong>Web-сервером</strong>. Вот и все! Общая идея заключается в том, что можно извлекать с сервера данные просто по мере необходимости, не обновляя всю страницу.</p>
<p>Прежде всего <strong>AJAX</strong> почти всегда опирается на серверный язык, такой, как <strong>PHP</strong> или <strong>ASP</strong>. Когда пользователю необходимо получить новые данные, <strong>JavaScript</strong> запрашивает их, а сервер, вероятно, запросит базу данных и затем вернет данные. Эти данные можно вернуть в различной форме. Если они структурированы, то это будут обычно данные <strong>XML</strong> или <strong>JSON</strong>. Если это очень простые данные (такие, как получение описания какого-то объекта), то можно часто увидеть людей, которые просто записывают эти данные непосредственно в ответ <strong>AJAX</strong>.</p>
<p>При создании запроса <strong>AJAX</strong> прежде всего необходимо создать объект <strong>XMLHTTP</strong>. <strong>Netscape/Firefox</strong>, <strong>Opera</strong> и другие браузеры имеют этот объект встроенным. <strong>Internet Explorer</strong> использует <strong>ActiveXObject</strong>. Поэтому мы создадим одну функцию для работы со всеми этими браузерами:</p>
<empty-line/>
<p><code>if(typeof(XMLHttpRequest)!='undefined'){</code></p>
<p><code>var getXMLHttpObj = function(){ return new XMLHttpRequest(); }</code></p>
<p><code>} else {</code></p>
<p><code>var getXMLHttpObj = function(){</code></p>
<p><code>var activeXObjects = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0',</code></p>
<p><code>'Msxml2.XMLHTTP.3.0', 'Msxml2.XMLHTTP', 'Microsoft.XMLHTTP'];</code></p>
<p><code>for(var i=0; i&lt;activeXObjects.length; i++){</code></p>
<p><code>try{</code></p>
<p><code>return new ActiveXObject(activeXObjects[i]);</code></p>
<p><code>}catch(err){}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Любой браузер, который поддерживает объект <strong>XMLHttpRequest</strong>, будет использовать этот встроенный объект. <strong>Internet Explorer 6</strong> и более ранние версии будут использовать объект <strong>ActiveX XMLHttp</strong> компании <strong>Microsoft</strong>. Существует много различных версий этого объекта, поэтому мы попробуем их все, начиная с самого нового.</p>
<p>Теперь, когда мы имеем объект <strong>XMLHttp</strong>, можно разместить запрос на сервере:</p>
<empty-line/>
<p><code>var oXml = getXMLHttpObj();</code></p>
<p><code>oXml.open('GET', 'getData.php', true);</code></p>
<p><code>oXml.onreadystatechange = processingFunction;</code></p>
<p><code>oXml.send();</code></p>
<empty-line/>
<p><code>function processingFunction(){</code></p>
<p><code>if(oXml.readyState!=4) return; // запрос не выполнен</code></p>
<empty-line/>
<p><code>// Результаты обрабатываются здесь. Подробнее дальше!</code></p>
<p><code>}</code></p>
<empty-line/>
<p>После создания объекта <strong>XMLHttp</strong> остается еще 4 дополнительных шага. Сначала определяются параметры соединения с помощью функции <strong>.open</strong>. Функция <strong>.open</strong> получает <strong>3</strong> аргумента: тип запроса, <strong>URL</strong> и флаг, который сообщает объекту, выполняться или нет асинхронно.</p>
<p>Первый аргумент, тип запроса, почти всегда будет <strong>GET</strong> или <strong>POST</strong>. Если извлекаются данные, то это будет обычно <strong>GET</strong>, а если отправляется форма с <strong>AJAX</strong>, то это часто будет <strong>POST</strong>.</p>
<p>Флаг асинхронности немного отличается почти от всего остального в <strong>JavaScript</strong>. Если этот флаг задан как <strong>false</strong>, то код продолжает выполняться, как и любой другой фрагмент кода, то есть он ожидает, пока объект <strong>XMLHttp</strong> завершит свою работу, прежде чем двигаться дальше. Однако, если этот флаг задан как <strong>true</strong>, то код продолжает делать то, что следует в коде после запроса. Когда состояние запроса изменяется, вызывается функция, которая определена в <strong>onreadystatechange</strong>.</p>
<p>В чем различие? Если флаг асинхронности задан как <strong>false</strong>, то браузер будет полностью заблокирован, пока обрабатывается запрос. Если запрошенные данные нужны в обязательном порядке для продолжения работы, то используйте это значение флага. Если флаг задан как <strong>true</strong>, то пользователь может продолжать использовать Web-страницу, но ничего не известно о том, когда вернется ответ на запрос. Может потребоваться <strong>1/2</strong> секунды или <strong>1</strong> минута. Все зависит от нагрузки на сервер и соединения конечного пользователя.</p>
<p>Когда все готово, посылается запрос. Затем мы ожидаем. Если запрос выполняется синхронно с функцией обработки, определенной с помощью <strong>onreadystatechange</strong>, то она будет вызываться несколько раз. На самом деле она вызывается всякий раз при изменении состояния запроса. Существуют различные состояния, такие, как отправка и загрузка данных, но нас интересует только завершение загрузки данных. Если <strong>readyState == 4</strong>, то запрос выполнен, поэтому в любом другом случае мы просто выходим из функции.</p>
<p>Теперь мы получили данные, но что это за данные?</p>
<p>Существует три возможных варианта получения данных: <strong>XML</strong>, <strong>JSON</strong> или обычный текст. При извлечении данных из базы данных, скорее всего, будет использоваться <strong>XML</strong> или <strong>JSON</strong>. Ни один из этих вариантов не имеет явных преимуществ. <strong>XML</strong> – широко распространенный стандарт, и поэтому существует много приложений, которые работают с файлами <strong>XML</strong>. <strong>JSON</strong> является более новой идеей, но быстро становится популярным. Его обычно легче прочитать (для человека), и он требует немного меньшую полосу пропускания для пересылки.</p>
<p>Предположим, что создается приложение для управления контактами. Cервер может возвращать информацию о людях. Одни и те же данные можно выразить в форме <strong>XML</strong> или <strong>JSON</strong>:</p>
<p><strong>XML:</strong></p>
<empty-line/>
<p><code>&lt;xml&gt;</code></p>
<p><code>&lt;contacts&gt;</code></p>
<p><code>&lt;person firstname="Joe" lastname="Smith" phone="555-1212" /&gt;</code></p>
<p><code>&lt;person firstname="Sam" lastname="Stevens" phone="123-4567" /&gt;</code></p>
<p><code>&lt;/contacts&gt;</code></p>
<p><code>&lt;/xml&gt;</code></p>
<empty-line/>
<p><strong>JSON:</strong></p>
<empty-line/>
<p><code>{contacts:[</code></p>
<p><code>{"firstname":"Joe", "lastname":"Smith", "phone":"555-1212"},</code></p>
<p><code>{"firstname":"Sam", "lastname":"Stevens", "phone":"123-4567"}</code></p>
<p><code>]}</code></p>
<empty-line/>
<p>Можно видеть, что нотация XML выглядит очень похоже на HTML. По большей части это так и есть. HTML и XML оба являются основанными на тегах языками и могут даже анализироваться одинаковым образом (см. Лекция 6).</p>
<p>Нотация <strong>JSON</strong> выглядит очень похоже на простой <strong>JavaScript</strong>. <strong>JSON</strong> означает <strong>JavaScript Object Notation</strong> и поэтому действительно является обычным <strong>JavaScript</strong>.</p>
<p>Данные в любой нотации можно посылать с Web-сервера просто как обычный текст. Никакие пробелы, имеющиеся в этих примерах, не нужны, за исключением одиночных пробелов между именами атрибутов в тегах <strong>person</strong> (в версии <strong>XML</strong>).</p>
<p>Формат <strong>XML</strong> является совокупностью тегов, очень похожих на <strong>HTML</strong>. Можно иметь любое количество тегов, вложенных друг в друга, и каждый тег может иметь любое количество атрибутов: например, <strong>firstname</strong>, <strong>lastname</strong> и <strong>phone</strong> в примере выше. Однако имеется несколько вещей, за которыми необходимо следить.</p>
<p><strong>[x]</strong> Каждый тег должен иметь закрывающий тег. Например, <strong>&lt;contacts&gt;</strong> закрывается с помощью расположенного ниже <strong>&lt;/contacts&gt;</strong>. Теги <strong>person</strong> являются замкнутыми. <strong>/&gt;</strong> в конце действует по сути как дополнительный закрывающий тег. Можно было так же легко написать один из них как <strong>&lt;person</strong> ... <strong>&gt;&lt;/person&gt;</strong>.</p>
<p><strong>[x] XML</strong> имеет ограниченный набор символов, которые можно использовать. В частности следующие символы являются недопустимыми в узлах и атрибутах и должны заменяться специальными комбинациями:</p>
<empty-line/>
<table>
<tr>
<td>&amp;</td>
<td>--&gt;</td>
<td>&amp;amp;</td>
</tr>
<tr>
<td>&lt;</td>
<td>--&gt;</td>
<td>&amp;lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>--&gt;</td>
<td>&amp;gt;</td>
</tr>
<tr>
<td>"</td>
<td>--&gt;</td>
<td>&amp;quot;</td>
</tr>
<tr>
<td>'</td>
<td>--&gt;</td>
<td>&amp;#39;</td>
</tr>
</table>
<empty-line/>
<p><code>Например, узел <strong>&lt;group name="Bill &amp; Paul" /&gt;</strong> является недопустимым и должен быть заменен на <strong>&lt;group name="Bill &amp;amp; Paul" /&gt;</strong>.</code></p>
<p><strong>[x]</strong> Приходящие с сервера данные должны посылаться с <strong>content-type</strong>, заданным как <strong>text/xml</strong>. Если извлекается файл с расширением <strong>.xml</strong>, то это должно происходить автоматически. Если данные извлекаются из сценария, необходимо задавать это вручную.</p>
<p>Для <strong>PHP</strong> добавьте следующее:</p>
<empty-line/>
<p><code>&lt;?php header('Content-type: text/xml'); ?&gt;</code></p>
<empty-line/>
<p>Для <strong>ASP</strong> добавьте:</p>
<empty-line/>
<p><code>&lt;% response.contentType = "text/xml" %&gt;</code></p>
<empty-line/>
<p><strong>[x]</strong> Для всех других языков добавьте эквивалентный заголовок <strong>content-type</strong>.</p>
<p>Если этот заголовок не задан, свойство <strong>responseXML</strong> объекта <strong>XMLHttp</strong> будет пустым (это свойство будет описано далее).</p>
<p><strong>JSON</strong> имеет аналогичный набор правил, и всю документацию по способам записи можно увидеть на <a l:href="http://www.json.org/">http://www.json.org/</a>. Однако упрощенно можно сказать, что:</p>
<p><strong>[x]</strong> объекты начинаются и заканчиваются с помощью символов <strong>{</strong> и <strong>}</strong> соответственно;</p>
<p><strong>[x]</strong> массивы начинаются и заканчиваются с помощью символов <strong>[</strong> и <strong>]</strong> соответственно;</p>
<p><strong>[x]</strong> все строки заключаются в двойные кавычки <strong>"</strong>;</p>
<p><strong>[x]</strong> символы <strong>"</strong> в строке должны экранироваться: <strong>\"</strong>.</p>
<p>Проще говоря, строка <strong>JSON</strong> должна представлять допустимый объект <strong>JavaScript</strong>.</p>
<p>Теперь посмотрим на то, как можно выполнить синтаксический разбор этих данных. В данный момент мы создадим просто сценарий, который сообщит, сколько имеется контактов, и выведет о них информацию. Начнем с версии <strong>XML</strong>, возвращаясь к предыдущему незаконченному фрагменту кода:</p>
<empty-line/>
<p><code>function processingFunction(){</code></p>
<p><code>if(oXml.readyState!=4) return; // запрос не выполнен</code></p>
<empty-line/>
<p><code>// Результаты обрабатываются здесь. Подробнее дальше!</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Когда скрипт попадает в тело функции, запрос <strong>XMLHttp</strong> будет выполнен. Объект <strong>XMLHttp</strong> имеет два метода для возврата данных: <strong>responseXML</strong> и <strong>responseText</strong>. Так как в данный момент мы работаем с файлом <strong>XML</strong>, то будем использовать <strong>responseXML</strong>:</p>
<empty-line/>
<p><code>function processingFunction(){</code></p>
<p><code>if(oXml.readyState!=4) return;</code></p>
<empty-line/>
<p><code>var xmlDoc = oXml.responseXML;</code></p>
<p><code>var contacts = xmlDoc.selectNodes('/xml/contacts/person');</code></p>
<empty-line/>
<p><code>alert('There are '+contacts.length+' contacts!');</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;contacts.length; i++){</code></p>
<p><code>alert('Contact #'+(i+1)+':\n\n'+</code></p>
<p><code>'First Name: '+contacts[i].getAttribute('firstname')+'\n'+</code></p>
<p><code>'Last Name: '+contacts[i].getAttribute('lastname') +'\n'+</code></p>
<p><code>'Phone #: '+contacts[i].getAttribute('phone') +'\n');</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Здесь имеется <strong>3</strong> функции вывода (<strong>alert</strong>). Одна сообщает, что имеется два контакта, а еще две выводят контактную информацию для каждого человека.</p>
<p>Посмотрим на тот же сценарий, использующий текст <strong>JSON</strong>:</p>
<empty-line/>
<p><code>function processingFunction(){</code></p>
<p><code>if(oXml.readyState!=4) return;</code></p>
<empty-line/>
<p><code>var json = eval('('+oXml.responseText+')');</code></p>
<empty-line/>
<p><code>alert('There are '+json.contacts.length+' contacts!');</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;json.contacts.length; i++){</code></p>
<p><code>alert('Contact #'+(i+1)+':\n\n'+</code></p>
<p><code>'First Name: '+json.contacts[i].firstname+'\n'+</code></p>
<p><code>'Last Name: '+json.contacts[i].lastname +'\n'+</code></p>
<p><code>'Phone #: '+json.contacts[i].phone +'\n');</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Как можно видеть, строки <strong>JSON</strong> можно преобразовать в <strong>JavaScript</strong>, используя просто встроенную в <strong>JavaScript</strong> команду <strong>eval()</strong>. Однако это можно делать, только если вы полностью доверяете источнику данных. Если это не так (если данные поступают из не вполне известного источника данных), то необходимо пропустить их в целях безопасности через <strong>JSON Parser</strong> (Анализатор <strong>JSON</strong>).</p>
<p>Наконец можно выбрать получение данных в любом другом простом текстовом формате вместо <strong>XML</strong> или <strong>JSON</strong>. Однако в этом случае необходимо решить, как выполнить синтаксический анализ данных. Если имеется только один фрагмент данных, такой, как комментарий, то это может быть практичным решением.</p>
<p>Что использовать: <strong>XML</strong> или <strong>JSON</strong>? Здесь нет больших различий. <strong>XML</strong> имеет более широко распространенный формат и переносим почти на любую систему. Если создаваемый проект будет работать с внешними источниками, то, вероятно, лучше использовать <strong>XML</strong>. Однако <strong>JSON</strong> немного легче для понимания и в общем он быстрее для разработки кода, чем <strong>XML</strong>. Если эта технология применяется для персонального проекта или в начале нового проекта, которому не нужно взаимодействовать с другими приложениям, то <strong>JSON</strong> определенно заслуживает рассмотрения.</p>
<p>В действительности уже есть все, что нужно для создания приложений <strong>AJAX</strong>, но мы рассмотрим достаточно простой пример. Мы собираемся написать небольшую таблицу данных (<strong>data grid</strong>), которая извлекает данные из трех различных файлов <strong>JSON</strong>. Для простоты эти файлы уже были сгенерированы. На практике эти файлы будут скорее всего генерироваться оперативно с помощью серверного сценария.</p>
<p><strong>Файл 1</strong></p>
<empty-line/>
<p><code>{contacts:[</code></p>
<p><code>{"firstname":"Steve" ,"lastname":"Smith", "phone":"555-1212"},</code></p>
<p><code>{"firstname":"Joe" ,"lastname":"Stevens", "phone":"555-0193"},</code></p>
<p><code>{"firstname":"Sam" ,"lastname":"Smith", "phone":"555-5120"},</code></p>
<p><code>{"firstname":"Dave" ,"lastname":"Stevens", "phone":"555-0521"},</code></p>
<p><code>{"firstname":"Suzy" ,"lastname":"Smith", "phone":"555-9410"},</code></p>
<p><code>{"firstname":"Jessica" ,"lastname":"Stevens", "phone":"555-8521"},</code></p>
<p><code>{"firstname":"James" ,"lastname":"Smith", "phone":"555-4781"},</code></p>
<p><code>{"firstname":"Jacob" ,"lastname":"Stevens", "phone":"555-9281"},</code></p>
<p><code>{"firstname":"Alex" ,"lastname":"Smith", "phone":"555-7261"},</code></p>
<p><code>{"firstname":"Tam" ,"lastname":"Stevens", "phone":"555-1820"}</code></p>
<p><code>]}</code></p>
<empty-line/>
<p><strong>Файл 2</strong></p>
<empty-line/>
<p><code>{contacts:[</code></p>
<p><code>{"firstname":"Nancy" ,"lastname":"Smith", "phone":"555-9583"},</code></p>
<p><code>{"firstname":"Elane" ,"lastname":"Stevens", "phone":"555-7281"},</code></p>
<p><code>{"firstname":"Shawn" ,"lastname":"Smith", "phone":"555-5782"},</code></p>
<p><code>{"firstname":"Jessie" ,"lastname":"Stevens", "phone":"555-7312"},</code></p>
<p><code>{"firstname":"Matt" ,"lastname":"Smith", "phone":"555-4928"},</code></p>
<p><code>{"firstname":"Jason" ,"lastname":"Stevens", "phone":"555-3917"},</code></p>
<p><code>{"firstname":"Daniel" ,"lastname":"Smith", "phone":"555-8711"},</code></p>
<p><code>{"firstname":"Shannon" ,"lastname":"Stevens", "phone":"555-0912"},</code></p>
<p><code>{"firstname":"Diana" ,"lastname":"Smith", "phone":"555-6172"},</code></p>
<p><code>{"firstname":"Mark" ,"lastname":"Stevens", "phone":"555-8831"}</code></p>
<p><code>]}</code></p>
<empty-line/>
<p><strong>Файл 3</strong></p>
<empty-line/>
<p><code>{contacts:[</code></p>
<p><code>{"firstname":"Laura" ,"lastname":"Stevens", "phone":"555-3915"},</code></p>
<p><code>{"firstname":"Jeff" ,"lastname":"Smith", "phone":"555-8614"},</code></p>
<p><code>{"firstname":"Frank" ,"lastname":"Stevens", "phone":"555-0213"},</code></p>
<p><code>{"firstname":"Elizabeth" ,"lastname":"Smith", "phone":"555-7531"},</code></p>
<p><code>{"firstname":"Jim" ,"lastname":"Stevens", "phone":"555-3951"}</code></p>
<p><code>]}</code></p>
<empty-line/>
<p>Эти файлы будут обеспечивать все данные для нашего списка контактов на <strong>AJAX</strong>. Построение списка контактов является в действительности вполне простым: создается таблица <strong>TABLE</strong> для хранения всех контактов и функция для очищения и повторного заполнения этой таблицы. Вот и все.</p>
<empty-line/>
<p><code>&lt;table cellspacing="1" cellpadding="3" bgcolor="#000000" style="font-family:tahoma;font-size:10px;"&gt;</code></p>
<p><code>&lt;tbody id="contactListTable"&gt;</code></p>
<p><code>&lt;tr style="background-color:#CCF;"&gt;</code></p>
<p><code>&lt;th&gt;First Name&lt;/th&gt;</code></p>
<p><code>&lt;th&gt;Last Name&lt;/th&gt;</code></p>
<p><code>&lt;th&gt;Phone #&lt;/th&gt;</code></p>
<p><code>&lt;/tr&gt;</code></p>
<p><code>&lt;/tbody&gt;</code></p>
<p><code>&lt;/table&gt;</code></p>
<empty-line/>
<p><code>function loadContactListPage(n){</code></p>
<p><code>var oXML = getXMLHttpObj();</code></p>
<p><code>oXML.open('GET', '/img/10_json_file'+n+'.txt', true);</code></p>
<p><code>oXML.onreadystatechange = function(){ doneLoading(oXML); }</code></p>
<p><code>oXML.send('');</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function doneLoading(oXML){</code></p>
<p><code>if(oXML.readyState!=4) return;</code></p>
<empty-line/>
<p><code>var json = eval('('+oXML.responseText+')');</code></p>
<p><code>var table = document.getElementById('contactListTable');</code></p>
<empty-line/>
<p><code>for(var i=table.childNodes.length-1; i&gt;0; i--){</code></p>
<p><code>table.removeChild(table.childNodes[i]);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>for(var i=0; i&lt;json.contacts.length; i++){</code></p>
<p><code>var tr = document.createElement('TR');</code></p>
<p><code>var td1 = document.createElement('TD');</code></p>
<p><code>var td2 = document.createElement('TD');</code></p>
<p><code>var td3 = document.createElement('TD');</code></p>
<empty-line/>
<p><code>tr.style.backgroundColor = i%2?'#FFF':'#E6E6E6';</code></p>
<empty-line/>
<p><code>table.appendChild(tr);</code></p>
<empty-line/>
<p><code>tr.appendChild(td1);</code></p>
<p><code>tr.appendChild(td2);</code></p>
<p><code>tr.appendChild(td3);</code></p>
<empty-line/>
<p><code>td1.appendChild(document.createTextNode(json.contacts[i].firstname));</code></p>
<p><code>td2.appendChild(document.createTextNode(json.contacts[i].lastname));</code></p>
<p><code>td3.appendChild(document.createTextNode(json.contacts[i].phone));</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><strong>Демонстрационный пример</strong></p>
<empty-line/>
<p><code>First Name Last Name Phone #</code></p>
<empty-line/>
<p><code>Steve Smith 555-1212</code></p>
<p><code>Joe Stevens 555-0193</code></p>
<p><code>Sam Smith 555-5120</code></p>
<p><code>Dave Stevens 555-0521</code></p>
<p><code>Suzy Smith 555-9410</code></p>
<p><code>Jessica Stevens 555-8521</code></p>
<p><code>James Smith 555-4781</code></p>
<p><code>Jacob Stevens 555-9281</code></p>
<p><code>Alex Smith 555-7261</code></p>
<p><code>Tam Stevens 555-1820</code></p>
<empty-line/>
<p><code>Page 1 | Page 2 | Page 3</code></p>
<empty-line/>
<p>Как можно видеть из примера выше, это все достаточно просто. Большая часть кода нужна в действительности просто для создания новых строк в таблице.</p>
<p><strong>AJAX</strong> может быть удивительно полезным инструментом. Его можно использовать для проверки форм перед их отправкой, для извлечения данных, как в этом примере, или для чего-то еще, что можно будет придумать. Однако в нормальной ситуации он не должен быть основным элементом Web-сайта. Обычно надо быть уверенным, что сайт будет доступен, даже если <strong>JavaScript</strong> будет отключен, но всегда существуют некоторые исключения для этого правила.</p>
<p>Следующая лекция будет посвящена обработке ошибок в <strong>JavaScript</strong>.</p>
</section>
<section>
<title>
<p><emphasis>Лекция 11.</emphasis> Обработка ошибок в JavaScript</p>
</title>
<p><emphasis>Обработка ошибок в JavaScript: Синтаксические ошибки. Ошибки времени выполнения. Window.onerror. Try/Catch/Finally и Throw. Обработка ошибок в AJAX</emphasis></p>
<p>Вы написали приложение <strong>JavaScript</strong>, и оно работает отлично – пока вы не получите сообщение об ошибке. Это нечто неприглядное, выскакивающее на экране, что-нибудь вроде <strong>'myObject.fields is null or not an object'</strong>. Что это значит? В этом уроке мы рассмотрим, как избавиться от ошибок, и покажем несколько различных методов для общей обработки ошибок.</p>
<p><strong>JavaScript</strong> имеет два основных уровня обработки ошибок: синтаксические ошибки и ошибки времени выполнения. Синтаксические ошибки возникают до выполнения кода JavaScript, означая в основном, что код невозможно компилировать. Возьмем, например, следующий код:</p>
<empty-line/>
<p><code>for(var i=0; i&lt;10; i++)</code></p>
<p><code>// рабочий код здесь</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Обратите внимание, что здесь пропущена открывающая скобка <strong>{</strong>. Если попробовать выполнить этот код, то немедленно появится сообщение об ошибке, даже если код находится в функции, которая не выполняется сразу. Такие ошибки почти всегда легко находятся и исправляются. В этом случае будет получено сообщение, говорящее что-нибудь подобное "<strong>Ожидалась ')', строка 10, позиция 18</strong>". Если перейти к строке <strong>10</strong>, то там обычно будет находиться достаточно очевидная ошибка, такая, как пропущенная <strong>)</strong>, дополнительный знак <strong>&lt;</strong>или какая-то другая опечатка. С такими ошибками ничего нельзя сделать, кроме как просто исправить и двигаться дальше. Ниже представлен список некоторых наиболее распространенных синтаксических ошибок:</p>
<p><strong>[x]</strong> Пропущенные или непарные фигурные, круглые или квадратные скобки</p>
<p>Каждая фигурная <strong>{</strong>, круглая <strong>(</strong>, или квадратная <strong>[</strong> скобка должна иметь свою закрывающую парную скобку. Если имеются вложенные скобки, то внутренние должны быть закрыты прежде, чем внешние. Например, набор скобок <strong>{[}]</strong> является недопустимым.</p>
<p><code>Условия операторов <strong>if</strong>, <strong>for</strong> и <strong>while</strong> должны помещаться в круглые скобки. Выражнение "<strong>if x=5{</strong>" является недопустимым, так как "<strong>x=5</strong>" должно быть заключено в круглые скобки. Если с этим возникнут проблемы, то существуют редакторы, такие, как <strong>EditPlus</strong>, которые могут выделять соответствующие пары скобок, и т.д.</code></p>
<p><strong>[x]</strong> Пропущенные или непарные кавычки</p>
<p>Это очень распространенная проблема. Строки в <strong>JavaScript</strong> начинаются символом <strong>'</strong>или <strong>"</strong> и должны заканчиваться таким же символом. Если этот символ существует в строке, то он должен быть экранирован. Например, код</p>
<empty-line/>
<p><code>var x = 'It's a beautiful day';</code></p>
<empty-line/>
<p>является недопустимым, потому что <strong>'</strong> в <strong>It's</strong> не экранировано. Этот код должен выглядеть следующим образом:</p>
<empty-line/>
<p><code>var x = 'It\'s a beautiful day';</code></p>
<empty-line/>
<p><code>// или</code></p>
<empty-line/>
<p><code>var x = "It's a beautiful day";</code></p>
<empty-line/>
<p>Еще одной достаточно распространенной ошибкой является завершение строки другим символом, т.е.:</p>
<empty-line/>
<p><code>var x = "It's a beautiful day';</code></p>
<empty-line/>
<p>Эта строка начинается с символа <strong>"</strong>, поэтому должна закончиться также символом <strong>"</strong>.</p>
<p><strong>[x]</strong> Пропущенная точка с запятой.</p>
<p>Хотя точки с запятой обычно не нужны в <strong>JavaScript</strong>, но лучше все же их использовать. Например, если нужно сократить файл <strong>JavaScript</strong>, то обычно удаляют все переносы строк. Возьмем следующий код:</p>
<empty-line/>
<p><code>var x=5</code></p>
<p><code>var y=10</code></p>
<empty-line/>
<p>Если удалить переносы строк, то получим код</p>
<empty-line/>
<p><code>var x=5 var y=10</code></p>
<empty-line/>
<p>который вызовет ошибку. Если бы использовались точки с запятой, то проблемы не было бы.</p>
<p>Перейдем к ошибкам времени выполнения. После запуска кода на исполнение начинают появляться ошибки времени выполнения. Эти ошибки могут возникать в связи с множеством причин. Каждый из следующих далее блоков кода будет порождать ошибку:</p>
<empty-line/>
<p><code>alert(x); // 'x' не определено</code></p>
<empty-line/>
<p><code>var x;</code></p>
<empty-line/>
<p><code>x[5] = 'test'; // 'x' будет null или не является объектом</code></p>
<empty-line/>
<p><code>window.frames = 5; // Не реализовано</code></p>
<empty-line/>
<p><code>var for; // ожидается идентификатор</code></p>
<empty-line/>
<p><code>document.doesNotExist(5);</code></p>
<p><code>// объект не поддерживает это свойство или метод</code></p>
<empty-line/>
<p><code>alert(parseInt('5')); // ожидается объект</code></p>
<empty-line/>
<p>Многие из этих проблем вызываются более общими ошибками, которые приходится разыскивать.</p>
<p><strong>[x]</strong> Неправильное использование прописных букв</p>
<p>Все встроенные функции <strong>JavaScript</strong> используют специальную форму записи имен функций, предполагающую, что имя функции начинается со строчной буквы, а в начале каждого следующего слова будет использоваться прописная буква: <strong>parseInt</strong>, getElementById, <strong>createElement</strong>, <strong>appendChild</strong>, и т.д.</p>
<p>Так как <strong>JavaScript</strong> учитывает регистр символов, то неправильный ввод имени одной из этих функций часто будет приводить к ошибке во время выполнения.</p>
<p><strong>[x]</strong> Ссылка на несуществующий код, функции или объекты <strong>DOM</strong> </p>
<p>Эта проблема возникает обычно в отношении объектов <strong>DOM</strong>. Предположим, что имеется код, который изменяет некоторые элементы формы на странице. Если делается попытка выполнить этот код до появления элементов формы, например, если поместить его в тег <strong>&lt;HEAD&gt;</strong>, то будет получена ошибка <strong>JavaScript</strong>.</p>
<p>Обычно эта проблема легко решается. Лучшим решением будет выполнение кода по событию <strong>onload</strong>, например:</p>
<empty-line/>
<p><code>&lt;BODY onload="loadFunction();"&gt;</code></p>
<empty-line/>
<p>или, еще лучше, присоединение события к загрузке тела:</p>
<empty-line/>
<p><code>document.captureEvents(Event.LOAD);</code></p>
<p><code>document.onLoad=loadFunction;</code></p>
<empty-line/>
<empty-line/>
<p><strong>[x]</strong> Использование зарезервированного слова</p>
<p>Существует длинный список зарезервированных ключевых слов <strong>JavaScript</strong>. Если делается попытка использовать многие из них вне их специального контекста, как, например, запись</p>
<empty-line/>
<p><code>var for = 5;</code></p>
<empty-line/>
<p>то будет возникать ошибка.</p>
<p><strong>[x]</strong> Использование пропущенного параметра</p>
<p>При определении функции обычно используется некоторое количество аргументов. Если некоторые из этих аргументов пропущены и делается попытка их использовать, то возникнут ошибки.</p>
<p>Большинство из этих проблем попадают в категорию опечаток и просто обычных ошибок, которые можно исправить, но необходимо о них знать, чтобы случайно не сделать.</p>
<p>Однако последний тип ошибки из этого списка с пропущенными параметрами можно проверить достаточно легко:</p>
<empty-line/>
<p><code>function myFunction(a, b, c){</code></p>
<p><code>if(a){</code></p>
<p><code>// выполняется работа с a</code></p>
<p><code>}</code></p>
<p><code>if(b &amp;&amp; c){</code></p>
<p><code>// выполняется работа с b и c</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Если функция вызывается только с одной переменной, то проблемы не возникает. Однако надо помнить об одной вещи: если входящая по значению переменная может быть определена как <strong>false (0</strong> или <strong>false</strong>), то код не будет работать. В связи с этим лучше проверять, что переменная не была определена:</p>
<empty-line/>
<p><code>function myFunction(a, b, c){</code></p>
<p><code>if(typeof(a)!='undefined'){</code></p>
<p><code>// выполнение кода с a</code></p>
<p><code>}</code></p>
<p><code>if((typeof(b)!='undefined') &amp;&amp; (typeof(c)!='undefined')){</code></p>
<p><code>// выполнение кода с b и c</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>В этом случае, даже если одна из переменных будет передана как <strong>0</strong>, <strong>false</strong> или <strong>null</strong>, код все равно будет работать.</p>
<p>Сейчас мы перейдем к изучению механизмов обработок ошибок – с помощью операторов Try/Catch и функции window.onerror.</p>
<p>Откровенно говоря, функция <strong>window.onerror</strong> имеет небольшую практическую пользу. Ее чаще всего используют для полного отключения всех сообщений об ошибках во время выполнения:</p>
<empty-line/>
<p><code>window.onerror = function(){</code></p>
<p><code>return true;</code></p>
<p><code>}</code></p>
<empty-line/>
<p>С этим кодом сообщение об ошибке никогда не будет выводиться. Однако в связи с этим приложение может не работать. Например, если бы переменная была <strong>null</strong> и с ней была выполнена какая-то операция, то в обычной ситуации должно появиться сообщение об ошибке. При использовании этого кода функция или сценарий в случае возникновения ошибки будет просто молча останавливаться.</p>
<p>Функцию <strong>window.onerror</strong> можно также использовать для вывода пользователям несколько более дружественных сообщений об ошибках. Можно просто вывести, например, сообщение <strong>'Произошла ошибка, свяжитесь, пожалуйста, с Web-мастером'</strong>, вместо вывода пользователю всех технических деталей ошибки (что большинство браузеров делает по умолчанию).</p>
<p>Еще одно использование <strong>window.onerror</strong> состоит в отправке разработчику списка всех ошибок, произошедших на сайте. Можно использовать <strong>AJAX</strong> для отправки сообщений об ошибках в форме, чтобы можно было позже их исправить. Все это возможно сделать неявно, без взаимодействия с пользователем.</p>
<p>Операторы <strong>Try/Catch</strong> являются несомненно наиболее распространенным и обычно лучшим способом реализовать обработку ошибок в <strong>JavaScript</strong>. Но не только это – операторы <strong>Try/Catch</strong> могут иногда быть единственным способом реализовать некоторые задачи, такие, как обнаружение объекта. Возьмем, например, простую функцию для создания в <strong>Internet Explorer</strong> объекта <strong>XMLHttp</strong>:</p>
<empty-line/>
<p><code>var activeXObjects = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0',</code></p>
<p><code>'Msxml2.XMLHTTP.3.0', 'Msxml2.XMLHTTP', 'Microsoft.XMLHTTP'];</code></p>
<p><code>for(var i=0; i&lt;activeXObjects.length; i++){</code></p>
<p><code>try{</code></p>
<p><code>return new ActiveXObject(activeXObjects[i]);</code></p>
<p><code>}catch(err){}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Заранее неизвестно, какие объекты установил пользователь, и, к сожалению, браузер не предоставляет никакого механизма это определить. Поэтому остается создавать каждый из 6 возможных объектов, пока один из них (будем надеяться) не заработает.</p>
<p>Операторы <strong>Try/Catch</strong> можно использовать для перехвата ошибок двух типов: ошибок времени выполнения и ошибок пользователя. Ошибки времени выполнения, как говорилось ранее, возникают, когда у компилятора <strong>JavaScript</strong> существует проблема с созданным кодом. Ошибки пользователя, с другой стороны, будут технически проходить без проблем, но возникают в связи с контекстом приложения. Если имеется поле, в которое пользователь, например, должен ввести свой возраст, и пользователь вводит <strong>– 2</strong>, то это приводит к появлению ошибки.</p>
<p>Блок <strong>Try/Catch</strong> имеет достаточно простой синтаксис:</p>
<empty-line/>
<p><code>try{</code></p>
<p><code>// код</code></p>
<p><code>}catch(err){</code></p>
<p><code>// код обработки ошибки</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Если код в блоке <strong>try</strong> приводит к ошибке, то сценарий немедленно переходит в блок <strong>catch</strong>. Объект ошибки <strong>err</strong> в <strong>JavaScript</strong> имеет ряд полезных свойств – описание, сообщение, имя и номер, которые можно использовать для вывода информации о том, что произошло:</p>
<empty-line/>
<p><code>try{</code></p>
<p><code>var x;</code></p>
<p><code>x[5] = 5;</code></p>
<p><code>}catch(err){</code></p>
<p><code>alert('An error occured: '+err.description);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Если в операторе <strong>catch</strong> окажется ошибка, то <strong>JavaScript</strong> сможет обратиться в дальнейшем к ее описанию.</p>
<p>Такой блок кода <strong>Try/Catch</strong> можно применять в любом месте. Однако, обычно, код должен быть написан таким образом, чтобы это не нужно было использовать, – в частности, весь ввод должен проверяться.</p>
<p>Блок <strong>Try/Catch</strong> можно применять также для создания своих собственных ошибок:</p>
<empty-line/>
<p><code>function setAge(x){</code></p>
<p><code>if(typeof(x)=='undefined') throw('Вы должны ввести возраст');</code></p>
<p><code>if(typeof(x)!='number') throw('Возраст должен быть числом');</code></p>
<p><code>if(x&lt;0) throw('Возраст не может быть меньше 0');</code></p>
<p><code>if(x&gt;120) throw('Возраст не может быть больше 120');</code></p>
<empty-line/>
<p><code>var myAge = x;</code></p>
<empty-line/>
<p><code>// еще код</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>try{</code></p>
<p><code>setAge(userInput);</code></p>
<p><code>}catch(err){</code></p>
<p><code>alert(err);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>В этом случае выполняется проверка того, что пользователь вводит возраст. Если он вводит недопустимые данные, сценарий немедленно завершается, а пользователь получает сообщение об ошибке.</p>
<p>Блок <strong>try/catch</strong> имеет еще одну часть, оператор <strong>finally</strong>:</p>
<empty-line/>
<p><code>try{</code></p>
<p><code>// код</code></p>
<p><code>}catch(err){</code></p>
<p><code>// код</code></p>
<p><code>}finally{</code></p>
<p><code>// код</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Код в "завершающем блоке" будет выполняться независимо от того, что происходит с операторами <strong>Try/Catch</strong>. В чем же разница между завершающим блоком и простым размещением кода после блока <strong>try/catch</strong>? В большинстве случаев никакой разницы не будет. Однако, если блок <strong>try/catch</strong> находится в функции и происходит выход из функции в блоке <strong>try</strong> или <strong>catch</strong>, то возникнет существенное различие:</p>
<empty-line/>
<p><code>function myFunction(){</code></p>
<p><code>try{</code></p>
<p><code>return someValue;</code></p>
<p><code>}catch(err){</code></p>
<p><code>return defaultValue;</code></p>
<p><code>}finally{</code></p>
<p><code>alert('finally!');</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>alert('End!');</code></p>
<p><code>}</code></p>
<empty-line/>
<p>В этом случае оба блока <strong>try</strong> и <strong>catch</strong> возвращают значение. Мы получим сообщение "<strong>finally!</strong>", но не получим сообщение "<strong>End!</strong>", потому что произойдет выход из функции до сообщения <strong>alert('End!')</strong>. То же самое остается справедливым для операторов <strong>Try/Catch</strong>, которые осуществляют выход из тела цикла <strong>for</strong> или <strong>while</strong>, например:</p>
<empty-line/>
<p><code>for(var i=0; i&lt;10; i++){</code></p>
<p><code>try{</code></p>
<p><code>if(i==5) continue;</code></p>
<p><code>}catch(err){</code></p>
<p><code>// обработка ошибки</code></p>
<p><code>}finally{</code></p>
<p><code>// код</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>// еще код</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Запросы <strong>XMLHttp</strong>, рассмотренные в предыдущей лекции, могут иметь совершенно другой тип ошибки: данные просто не проходят. Это можно проверить через статус объекта <strong>XMLHttp</strong>:</p>
<empty-line/>
<p><code>function processingFunction(){</code></p>
<p><code>if(oXml.readyState!=4) return; // запрос не выполнен</code></p>
<empty-line/>
<p><code>switch(oXml.status){</code></p>
<p><code>case 0: case 200: // запрос выполнен</code></p>
<p><code>break;</code></p>
<p><code>case 408: case 504: // запрос превысил время ожидания</code></p>
<p><code>// код</code></p>
<p><code>break;</code></p>
<p><code>default: // ошибка запроса</code></p>
<p><code>// код</code></p>
<p><code>return; // возможно, вы захотите выйти</code></p>
<p><code>break;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>// продолжение обработки запроса</code></p>
<p><code>}</code></p>
<empty-line/>
<p><strong>oXml</strong> в этом примере является объектом <strong>XMLHttp</strong>, а функция <strong>processingFunction</strong> была присоединена к свойству <strong>onreadystatechange</strong> этого объекта.</p>
<p>Проверяя код статуса, мы узнаем, был ли запрос обработан успешно. Код <strong>200</strong> является в HTTP стандартным кодом статуса "Все прошло нормально" . Код <strong>0</strong> возникает при загрузке файлов из локальной файловой системы (если для этого есть соответствующие полномочия). Статус код <strong>0</strong> часто возникает при локальном тестировании приложения.</p>
<p>Коды статуса <strong>408</strong> и <strong>504</strong> представляют ситуацию с превышением времени ожидания. Очень часто это указывает на сетевые проблемы, и простое повторение запроса может разрешить проблему. Однако отметим, что эти коды представляют также слишком длительную работу сервера над ответом. Например, если существует ошибка сценария на сервере, которая приводит к бесконечному циклу, то может возникнуть код ошибки <strong>408</strong> или <strong>504</strong>. В этом случае повторная попытка будет вредоносной, поэтому надо быть осторожным. Самым безопасным является уведомление пользователя и выход из функции, но это не очень корректно по отношению к пользователю.</p>
<p>Все другие коды ошибок имеют свои собственные значения, но в данной ситуации это не важно. Нас интересует только то, что мы не получили нужные данные. Поэтому если код попадает в область "<strong>default</strong>", то мы имеем проблему. Наверно в этой ситуации лучше всего сообщить пользователю о проблеме и выйти из функции.</p>
<p>Это почти все об обработке ошибок в <strong>JavaScript</strong>. Имеет смысл включать в функции обработку ошибок, но, возможно, что это не требуется для каждой функции или каждого фрагмента кода. В большинстве ситуаций достаточно проверки ввода пользователей. Для реализации проверки пользователя наиболее полезным средством является использование блоков <strong>Try/Catch/Throw</strong>.</p>
<p>В следующей лекции будет рассмотрена рекурсия: </p>
<cite>
<p>"Чтобы понять рекурсию, сначала необходимо понять рекурсию".</p>
</cite>
<empty-line/>
</section>
<section>
<title>
<p><emphasis>Лекция 12.</emphasis> Рекурсия</p>
</title>
<p><emphasis>Рекурсия. Стек. Создание собственного стека. Применение рекурсии. "Чтобы понять рекурсию, сначала необходимо понять рекурсию".</emphasis></p>
<p>Данное высказывание очень четко выражает суть рекурсии. Рекурсия является базовой концепцией программирования вообще, а не только <strong>JavaScript</strong>, понимание которой очень полезно. Она включает вызов функции из той же самой функции. Почему это может понадобиться? Предположим, что имеется массив массивов. Каждый из этих массивов может иметь в себе массивы, которые могут иметь массивы, которые могут иметь ... собственно, в этом и состоит идея. Таким образом мы имеем множество массивов в других массивах. Как выполнить одну и ту же операцию на всех элементах во всех этих массивах? Можно попробовать использовать простой цикл <strong>for</strong>, но неизвестно, сколько имеется массивов, и неизвестно, как глубоко распространяется вложение массивов. Поэтому остается только концепция рекурсии.</p>
<p>В этом примере мы циклически перебираем все элементы массива первого уровня. Если какой-либо из этих элементов в массиве сам будет массивом, мы снова вызываем функцию, передавая этот элемент как первичный массив. Затем функция будет перебирать этот массив и снова вызывать себя, пока не останется ни одного массива.</p>
<p>Другим хорошим примером рекурсии будет написание синтаксического анализатора документа <strong>XML</strong>. Каждый узел документа <strong>XML</strong> можно анализировать совершенно одинаково, поэтому мы можем разбить всю задачу на множество более мелких одинаковых шагов.</p>
<p>Самым трудным в рекурсии является ее понимание. Такие концепции, как циклы, воспринимаются достаточно естественно, в то время как рекурсия трудна для большинства людей. Рекурсивные функции также очень часто требуют больше памяти, чем нерекурсивные функции. Если имеется функция, которая вызывает себя на <strong>20</strong> уровней вглубь, потребуется как минимум в <strong>20</strong> раз больше памяти.</p>
<p>Простым примером будет написание рекурсивной функции факториала. Факториал <strong>N</strong>, записываемый как <strong>N!</strong>, определяется как произведение всех чисел от <strong>N</strong> до <strong>1</strong>. Поэтому <strong>5!</strong> будет равен <strong>5*4*3*2*1 = 120</strong>.</p>
<empty-line/>
<p><code>function factorial(N){</code></p>
<p><code>return N&lt;=1?1:N*factorial(N-1);</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Демонстрационный пример. Факториал</p>
<empty-line/>
<p>Очень элегантное решение, не правда ли? В результате мы вызываем функцию факториала <strong>5</strong> раз для <strong>N = 5</strong>. Можно в действительности развернуть всю рекурсивную функцию и получить <strong>(5*(4*(3*(2*(1)))))</strong>. Каждая пара скобок представляет новый вызов функции факториала. Можно также видеть, что если пользователь вводит число <strong>&lt;=1</strong>, то всегда получит в качестве результата <strong>1</strong>.</p>
<p>Давайте рассмотрим другой пример. При работе с программами рисования, такими, как <strong>Photoshop</strong> или <strong>MS Paint</strong>, иногда используется инструмент заливки (<strong>flood fill</strong>). Этот инструмент заливает выбранный цвет другим, указанным цветом. Это делается рекурсивно, и алгоритм заливки достаточно прямолинеен:</p>
<empty-line/>
<p><code>/*</code></p>
<p><code>это – псевдокод, быстро написанный и не функциональный,</code></p>
<p><code>который должен просто дать общую идею о том, как действует</code></p>
<p><code>реальный код</code></p>
<p><code>*/</code></p>
<empty-line/>
<p><code>function floodFill(x, y){</code></p>
<p><code>if(alreadyFilled(x, y)) return;</code></p>
<p><code>fill(x, y);</code></p>
<empty-line/>
<p><code>floodFill(x, y-1);</code></p>
<p><code>floodFill(x+1, y );</code></p>
<p><code>floodFill(x, y+1);</code></p>
<p><code>floodFill(x-1, y );</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function fill(x, y){</code></p>
<p><code>// эта функция будет фактически изменять цвет поля</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function alreadyFilled(x, y){</code></p>
<p><code>// эта функция проверяет, что поле уже было закрашено</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Идея этого кода состоит в том, чтобы закрасить текущий квадрат или пиксель. Затем он пытается закрасить квадрат выше, справа, ниже и слева от себя. При таком алгоритме каждый квадрат будет закрашен достаточно быстро. Однако здесь возникает небольшая проблема – размер стека.</p>
<p>При вызове функции копия множества переменных, которые нужны ей для работы, сохраняется в памяти. Если функция вызывается рекурсивно, то другая копия всех этих переменных сохраняется в памяти, затем еще одна и т.д. Эти копии переменных сохраняются в так называемом стеке. Первая копия находится внизу, следующая поверх нее, и т.д. К сожалению, существует ограничение на размер стека. В большинстве браузеров этот предел определен где-то в районе <strong>1000</strong>. Это означает, что для функции заливки сетка могла бы содержать до <strong>1000</strong> квадратов. Некоторые браузеры имеют меньший размер стека. Web-браузер <strong>Safari</strong>, например, имеет максимальный размер стека, равный примерно <strong>100</strong>, поэтому даже небольшая сетка <strong>10 х 10</strong> исчерпает возможности браузера.</p>
<p>Таким образом мы имеем ограничение в самом браузере, которое определяет, что при использовании рекурсии можно углубиться только на <strong>1000</strong> уровней. К сожалению, наш алгоритм <strong>floodFill</strong> (заливки) будет в худшем случае углубляться на <strong>1000</strong> уровней на сетке, содержащей только <strong>1000</strong> полей. Если имеется что-то более сложное, то существует вероятность, что произойдет переполнение стека и просто остановка выполнения кода. Очевидно, что существуют ситуации, когда необходимо закрасить область, содержащую более <strong>1000</strong> пикселей. Что делать в таком случае? Попробуем изменить подход.</p>
<p>Прежде всего попробуем изменить алгоритм. Существует много различных алгоритмов закраски – мы использовали один из самых простых. Он проверяет все направления и затем закрашивает каждый просмотренный квадрат, если это будет необходимо. С помощью небольшого изменения можно существенно улучшить этот алгоритм, с точки зрения необходимого пространства стека. Вместо просмотра влево и вправо на <strong>1</strong> квадрат, можно просматривать влево и вправо на максимально возможное количество позиций и закрашивать каждый пиксель в этом направлении. Это называется алгоритмом закрашивания со сканированием по линиям, который оказывается одним из наиболее эффективных существующих алгоритмов закрашивания. К сожалению, он все еще имеет свои ограничения, и для достаточно большой области закрашивания он также может переполнять стек.</p>
<p>Если это произойдет, то остается единственный вариант: не использовать рекурсию. Вместо использования стека <strong>JavaScript</strong> можно создать свой собственный с помощью простого массива <strong>JavaScript</strong>. Так как массив не имеет ограничений на количество элементов массива, то можно получить "бесконечно" большой стек, которым мы управляем самостоятельно.</p>
<p>Чтобы создать свой собственный стек, необходимо удалить рекурсивную часть нашей функции. Мы все равно собираемся многократно вызывать функцию, но собираемся вызывать ее из другой функции, а не из себя самой.</p>
<empty-line/>
<p><code>var Stack = [];</code></p>
<empty-line/>
<p><code>function floodFill(x, y){</code></p>
<p><code>fillPixel(x, y);</code></p>
<empty-line/>
<p><code>while(Stack.length&gt;0){</code></p>
<p><code>toFill = Stack.pop();</code></p>
<p><code>fillPixel(toFill[0], toFill[1]);</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function fillPixel(x, y){</code></p>
<p><code>if(!alreadyFilled(x, y)) fill(x, y);</code></p>
<empty-line/>
<p><code>if(!alreadyFilled(x, y-1)) Stack.push([x, y-1]);</code></p>
<p><code>if(!alreadyFilled(x+1, y )) Stack.push([x+1, y ]);</code></p>
<p><code>if(!alreadyFilled(x, y+1)) Stack.push([x, y+1]);</code></p>
<p><code>if(!alreadyFilled(x-1, y )) Stack.push([x-1, y ]);</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function fill(x, y){</code></p>
<p><code>// эта функция будет фактически изменять цвет поля</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function alreadyFilled(x, y){</code></p>
<p><code>// эта функция проверяет, что квадрат еще не был закрашен</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Как можно видеть, процесс не намного сложнее, но требует немного больше микроуправления, чем написанный ранее рекурсивный код. Вместо рекурсивного вызова функции <strong>floodFill</strong> создается переменная <strong>Stack</strong>, содержащая список квадратов, которые необходимо закрасить. Затем функция <strong>fillPixel</strong> заполняет этот массив, а функция <strong>floodFill</strong> извлекает последний элемент и закрашивает его. Когда все будет сделано, результат будет таким же, как и у первой функции, которая была написана, с одним исключением: эта функция не имеет никаких ограничений в отношении величины сетки.</p>
<p>Отметим, что существует очень немного рекурсивных функций, которые будут реально переполнять стек <strong>JavaScript</strong>. В действительности это не совсем верно. Почти любая рекурсивная функция может переполнить стек, но чаще всего данные, которые функция получает от пользователя, делают это крайне маловероятным событием. Когда, например, вы встретите документ <strong>XML</strong> с глубиной вложения узлов, равной <strong>1000</strong>? Почти наверняка – никогда.</p>
<p>Теперь, имея некоторое представление о рекурсии, надо попытаться понять, что с ней можно делать, кроме закрашивания изображений. Одним из наиболее распространенных рекурсивных алгоритмов будет так называемый двоичный поиск. Это можно представить себе как игру на больше-меньше. Если кто-то предлагает угадать число от <strong>1</strong> до <strong>100</strong>, то, скорее всего, начать лучше с <strong>50</strong>. Если партнер скажет, что больше, то можно предположить <strong>75</strong> и т.д. Это можно продолжать, пока число не будет найдено.</p>
<p>Как оказывается, это один из самых быстрых способов поиска данных, когда известно, что все данные уже отсортированы. Если имеется список из <strong>1000000</strong> позиций и требуется найти одну из них, то можно начать с <strong>500000</strong> и использовать тот же процесс, что и в игре "больше-меньше".</p>
<p>Для сортировки применяются специальные алгоритмы. Многие алгоритмы сортировки, включая один из самых быстрых, <strong>QuickSort</strong>, используют рекурсию. Алгоритм <strong>QuickSort</strong> разбивает данные на фрагменты, сортирует каждый фрагмент по отдельности, рекурсивно разбивает фрагменты на меньшие фрагменты и сортирует их.</p>
<p>Другим широко распространенным использованием рекурсии является проверка или синтаксический анализ некоторых данных. Ранее в качестве примера упоминался файл <strong>XML</strong>, но с помощью рекурсии можно эффективно выполнять многие другие формы синтаксического анализа, такие, как подсчет количества вхождений слова или фразы в предложении или книге.</p>
<p>Рекурсия является крайне полезной концепцией. Рекурсия может использоваться не так часто, но когда она находит применение, она существенно облегчает жизнь программиста.</p>
</section>
<section>
<title>
<p><emphasis>Дополнение I.</emphasis> Краткое руководство по AJAX</p>
</title>
<p>Технология AJAX является не новым языком программирования, а просто новым способом использования существующих стандартов.</p>
<p>С помощью AJAX можно создавать Web-приложения, которые будут лучше, быстрее и удобнее для пользователей, чем существующие.</p>
<p>AJAX основывается на JavaScript и запросах HTTP.</p>
<p>AJAX является сокращением от "Asynchronous JavaScript And XML" (Асинхронный JavaScript и XML).</p>
<p>AJAX является не новым языком программирования, а просто новым способом создания Web-приложений, которые будут лучше, быстрее, и более интерактивными.</p>
<p>AJAX использует JavaScript для отправки и получения данных при взаимодействии Web-браузера и Web-сервера.</p>
<p>Технология AJAX делает Web-страницы более гибкими и быстро реагирующими, осуществляя обмен данными с Web-сервером в фоновом режиме, а не перезагружая всю Web-страницу всякий раз, когда пользователь делает изменение.</p>
<p>AJAX является технологией, которая выполняется в браузере клиента. Она использует асинхронную передачу данных (запросы HTTP) между браузером и Web-сервером, позволяя Web-страницам запрашивать с сервера небольшие объемы данных вместо целых страниц.</p>
<p>Эта технология позволяет уменьшить объем приложений Интернет, сделать их более быстрыми и более удобными для пользователей.</p>
<p>AJAX является технологией Web-браузера, которая не зависит от программного обеспечения Web-сервера.</p>
<p>AJAX использует следующие открытые стандарты:</p>
<p><strong>JavaScript</strong></p>
<p><strong>XML</strong></p>
<p><strong>HTML</strong></p>
<p><strong>CSS</strong></p>
<p>Используемые в AJAX открытые стандарты строго определены и поддерживаются всеми основными браузерами. Приложения AJAX не зависят от используемых браузеров и платформ.</p>
<p>Web-приложения имеют множество преимуществ при сравнении с традиционными приложениями настольных компьютеров. Они имеют более обширную аудиторию, их легче устанавливать и поддерживать, и их легче разрабатывать.</p>
<p>Однако приложения Интернет не всегда бывают достаточно "богаты" свойствами и удобны для использования по сравнению с традиционными приложениями.</p>
<p>С помощью AJAX приложения Интернет можно сделать богаче (меньше, быстрее, и легче в использовании).</p>
<p>Нет ничего нового, что требует изучения.</p>
<p>Технология AJAX основывается на открытых стандартах. Эти стандарты использовались множеством разработчиков многие годы.</p>
<p>Большинство существующих Web-приложений можно легко переписать с помощью технологии AJAX вместо традиционных форм HTML.</p>
<p>Традиционное Web-приложение посылает введенные данные на Web-сервер (используя форму HTML). После обработки данных Web-сервер возвращает пользователю совершенно новую Web-страницу.</p>
<p>Так как сервер возвращает новую Web-страницу всякий раз, когда пользователь посылает данные на сервер, то традиционное Web-приложение часто выполняется медленно и оказывается менее удобным для пользователя.</p>
<p>С помощью AJAX Web-приложения могут посылать и получать данные без перезагрузки всей Web-страницы. Это делается с помощью запросов HTTP, посылаемых на сервер (в фоновом режиме), и модификации только отдельных частей Web-страницы с помощью JavaScript, когда сервер возвращает данные.</p>
<p>XML используется обычно в качестве формата для получения данных сервера, хотя можно использовать любой формат, включая обычный текст.</p>
<p>Как это делается, будет показано далее в этом кратком руководстве.</p>
<p>Технологию AJAX можно использовать для создания приложений с большими интерактивными возможностями.</p>
<p>В следующем примере приложения AJAX показано, как Web-страница может оперативно общаться с Web-сервером, когда пользователь вводит данные в Web-форму.</p>
<p>На странице выводится поле ввода с предложением ввести имя. Когда пользователь начинает вводить в этом поле имя, ниже появляются возможные варианты имен.</p>
<p>Пусть на Web-странице имеется форма HTML со следующим кодом:</p>
<empty-line/>
<p>&lt;form&gt;</p>
<p><code>Имя:</code></p>
<p><code>&lt;input type="text" id="txt1"</code></p>
<p><code>onkeyup="showHint(this.value)"&gt;</code></p>
<p><code>&lt;/form&gt;</code></p>
<p><code>&lt;p&gt;Советуем: &lt;span id="txtHint"&gt;&lt;/span&gt;&lt;/p&gt;</code></p>
<empty-line/>
<p>Как можно видеть, это простая форма HTML с полем ввода с именем "txt1".</p>
<p>Атрибут события этого поля ввода определяет функцию, которая будет запускаться при возникновении события onkeyup.</p>
<p>Параграф ниже формы содержит тег <strong>span</strong> с именем "txtHint". Тег <strong>span</strong> используется в качестве поля для подстановки данных, получаемых с Web-сервера.</p>
<p>Когда пользователь вводит данные, выполняется функция с именем "showHint()". Выполнение функции запускается событием "onkeyup". Другими словами, всякий раз, когда пользователь убирает свой палец с клавиатуры внутри поля ввода (отпускает нажатую клавишу), вызывается функция <strong>showHint</strong>.</p>
<p>Функция <strong>showHint()</strong> является очень простой функцией JavaScript, помещенной в раздел заголовка <strong>&lt;head&gt;</strong> страницы HTML.</p>
<p>Функция имеет следующий код:</p>
<empty-line/>
<p>function showHint(str)</p>
<p><code>{</code></p>
<p><code>if (str.length==0)</code></p>
<p><code>{</code></p>
<p><code>document.getElementById("txtHint").innerHTML=""</code></p>
<p><code>return</code></p>
<p><code>}</code></p>
<p><code>xmlHttp=GetXmlHttpObject()</code></p>
<p><code>if (xmlHttp==null)</code></p>
<p><code>{</code></p>
<p><code>alert ("Браузер не поддерживает запросы HTTP")</code></p>
<p><code>return</code></p>
<p><code>}</code></p>
<p><code>var url="gethint.asp"</code></p>
<p><code>url=url+"?q="+str</code></p>
<p><code>url=url+"&amp;sid="+Math.random()</code></p>
<p><code>xmlHttp.onreadystatechange=stateChanged</code></p>
<p><code>xmlHttp.open("GET",url,true)</code></p>
<p><code>xmlHttp.send(null)</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Функция выполняется всякий раз, когда в поле ввода вводится символ.</p>
<p>Если имеется какой-то ввод в текстовое поле (<strong>str.length &gt; 0</strong>), то функция выполняет следующее:</p>
<p><strong>[x]</strong> Определяет url (имя файла) для отправки на сервер</p>
<p><strong>[x]</strong> Добавляет к url параметр (<strong>q</strong>) с содержимым поля ввода</p>
<p><strong>[x]</strong> Добавляет случайное число, чтобы сервер не использовал кэшированный файл</p>
<p><strong>[x]</strong> Создает объект XMLHTTP, и приказывает объекту выполнить функцию с именем <strong>stateChanged</strong>, когда произойдет изменение.</p>
<p><strong>[x]</strong> Открывает объект <strong>XMLHTTP</strong> с заданным url.</p>
<p><strong>[x]</strong> Посылает запрос HTTP на сервер</p>
<p>Если поле ввода будет пустым, то функция просто очищает содержимое поля для подстановки <strong>txtHint</strong>.</p>
<p>Функция <strong>stateChanged()</strong> содержит следующий код:</p>
<empty-line/>
<p>function stateChanged()</p>
<p><code>{</code></p>
<p><code>if (xmlHttp.readyState==4 || xmlHttp.readyState=="complete")</code></p>
<p><code>{</code></p>
<p><code>document.getElementById("txtHint").innerHTML=xmlHttp.responseText</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Функция <strong>stateChanged()</strong> выполняется всякий раз, когда изменяется состояние объекта XMLHTTP.</p>
<p>Когда состояние будет равно 4 (или "complete"), поле для подстановки <strong>txtHint</strong> получает содержимое текста пришедшего ответа.</p>
<p>Приложения AJAX могут выполняться только в Web-браузерах с поддержкой XML.</p>
<p>Приложения AJAX могут выполняться только в Web-браузерах с полной поддержкой XML, т.е. всеми основными современными браузерами.</p>
<p>Предыдущий пример вызывает функцию с именем <strong>GetXmlHttpObject</strong>.</p>
<p>Эта функция предназначена для решения проблемы создания различных объектов <strong>XMLHTTP</strong> для различных браузеров.</p>
<p>Функция имеет следующий код:</p>
<empty-line/>
<p>function GetXmlHttpObject(handler)</p>
<p><code>{</code></p>
<p><code>var objXMLHttp=null</code></p>
<p><code>if (window.XMLHttpRequest)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new XMLHttpRequest()</code></p>
<p><code>}</code></p>
<p><code>else if (window.ActiveXObject)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new ActiveXObject("Microsoft.XMLHTTP")</code></p>
<p><code>}</code></p>
<p><code>return objXMLHttp</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Далее показан полный исходный код рассмотренного выше примера AJAX.</p>
<p>Эта страница HTML содержит простую форму HTML и ссылку на файл JavaScript.</p>
<empty-line/>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;script src="clienthint.js"&gt;&lt;/script&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;form&gt;</code></p>
<p><code>Имя:</code></p>
<p><code>&lt;input type="text" id="txt1"</code></p>
<p><code>onkeyup="showHint(this.value)"&gt;</code></p>
<p><code>&lt;/form&gt;</code></p>
<p><code>&lt;p&gt;Советуем: &lt;span id="txtHint"&gt;&lt;/span&gt;&lt;/p&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p>Это код JavaScript, который находится в файле "clienthint.js":</p>
<empty-line/>
<p><code>var xmlHttp</code></p>
<empty-line/>
<p><code>function showHint(str)</code></p>
<p><code>{</code></p>
<p><code>if (str.length==0)</code></p>
<p><code>{</code></p>
<p><code>document.getElementById("txtHint").innerHTML=""</code></p>
<p><code>return</code></p>
<p><code>}</code></p>
<p><code>xmlHttp=GetXmlHttpObject()</code></p>
<p><code>if (xmlHttp==null)</code></p>
<p><code>{</code></p>
<p><code>alert ("Браузер не поддерживает запросы HTTP")</code></p>
<p><code>return</code></p>
<p><code>}</code></p>
<p><code>var url="gethint.asp"</code></p>
<p><code>url=url+"?q="+str</code></p>
<p><code>url=url+"&amp;sid="+Math.random()</code></p>
<p><code>xmlHttp.onreadystatechange=stateChanged</code></p>
<p><code>xmlHttp.open("GET",url,true)</code></p>
<p><code>xmlHttp.send(null)</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function stateChanged()</code></p>
<p><code>{</code></p>
<p><code>if (xmlHttp.readyState==4 || xmlHttp.readyState=="complete")</code></p>
<p><code>{</code></p>
<p><code>document.getElementById("txtHint").innerHTML=xmlHttp.responseText</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function GetXmlHttpObject()</code></p>
<p><code>{</code></p>
<p><code>var objXMLHttp=null</code></p>
<p><code>if (window.XMLHttpRequest)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new XMLHttpRequest()</code></p>
<p><code>}</code></p>
<p><code>else if (window.ActiveXObject)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new ActiveXObject("Microsoft.XMLHTTP")</code></p>
<p><code>}</code></p>
<p><code>return objXMLHttp</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Далее речь пойдет о серверной странице AJAX.</p>
<p>Сервера AJAX не существует.</p>
<p>Страницы AJAX может обрабатывать любой сервер Интернет.</p>
<p>Серверная страница, вызываемая сценарием JavaScript в рассматриваемом примере, является простым файлом ASP с именем "gethint.asp".</p>
<p>Ниже представлены два примера кода серверной страницы, один, написанный на ASP, а другой – на PHP.</p>
<p>Код на странице "gethint.asp" написан на VBScript для Информационного сервера Интернет (IIS). Он просто проверяет массив имен и возвращает клиенту подходящие имена:</p>
<empty-line/>
<p><code>&lt;%</code></p>
<p><code>dim a(30)</code></p>
<p><code>'Заполнение массива именами</code></p>
<p><code>a(1)="Anna"</code></p>
<p><code>a(2)="Brittany"</code></p>
<p><code>a(3)="Cinderella"</code></p>
<p><code>a(4)="Diana"</code></p>
<p><code>a(5)="Eva"</code></p>
<p><code>a(6)="Fiona"</code></p>
<p><code>a(7)="Gunda"</code></p>
<p><code>a(8)="Hege"</code></p>
<p><code>a(9)="Inga"</code></p>
<p><code>a(10)="Johanna"</code></p>
<p><code>a(11)="Kitty"</code></p>
<p><code>a(12)="Linda"</code></p>
<p><code>a(13)="Nina"</code></p>
<p><code>a(14)="Ophelia"</code></p>
<p><code>a(15)="Petunia"</code></p>
<p><code>a(16)="Amanda"</code></p>
<p><code>a(17)="Raquel"</code></p>
<p><code>a(18)="Cindy"</code></p>
<p><code>a(19)="Doris"</code></p>
<p><code>a(20)="Eve"</code></p>
<p><code>a(21)="Evita"</code></p>
<p><code>a(22)="Sunniva"</code></p>
<p><code>a(23)="Tove"</code></p>
<p><code>a(24)="Unni"</code></p>
<p><code>a(25)="Violet"</code></p>
<p><code>a(26)="Liza"</code></p>
<p><code>a(27)="Elizabeth"</code></p>
<p><code>a(28)="Ellen"</code></p>
<p><code>a(29)="Wenche"</code></p>
<p><code>a(30)="Vicky"</code></p>
<p><code>'извлечение параметра q из URL</code></p>
<p><code>q=ucase(request.querystring("q"))</code></p>
<p><code>'поиск всех рекомендаций из массива, если длина q&gt;0</code></p>
<p><code>if len(q)&gt;0 then</code></p>
<p><code>hint=""</code></p>
<p><code>for i=1 to 30</code></p>
<p><code>if q=ucase(mid(a(i),1,len(q))) then</code></p>
<p><code>if hint="" then</code></p>
<p><code>hint=a(i)</code></p>
<p><code>else</code></p>
<p><code>hint=hint &amp; "," &amp; a(i)</code></p>
<p><code>end if</code></p>
<p><code>end if</code></p>
<p><code>next</code></p>
<p><code>end if</code></p>
<p><code>'Вывод "нет предложений" если рекомендуемого имени не найдено</code></p>
<p><code>'или вывод подходящих значений</code></p>
<p><code>if hint="" then</code></p>
<p><code>response.write("нет предложений")</code></p>
<p><code>else</code></p>
<p><code>response.write(hint)</code></p>
<p><code>end if</code></p>
<p><code>%&gt;</code></p>
<empty-line/>
<p>Приведенный выше код переписан на PHP.</p>
<p>Примечание: Чтобы выполнить весь пример на PHP, не забудьте изменить значение переменной url в "clienthint.js" с "gethint.asp" на "gethint.php".</p>
<empty-line/>
<p><code>&lt;?php</code></p>
<p><code>// Заполняем массив именами</code></p>
<p><code>$a[]="Anna";</code></p>
<p><code>$a[]="Brittany";</code></p>
<p><code>$a[]="Cinderella";</code></p>
<p><code>$a[]="Diana";</code></p>
<p><code>$a[]="Eva";</code></p>
<p><code>$a[]="Fiona";</code></p>
<p><code>$a[]="Gunda";</code></p>
<p><code>$a[]="Hege";</code></p>
<p><code>$a[]="Inga";</code></p>
<p><code>$a[]="Johanna";</code></p>
<p><code>$a[]="Kitty";</code></p>
<p><code>$a[]="Linda";</code></p>
<p><code>$a[]="Nina";</code></p>
<p><code>$a[]="Ophelia";</code></p>
<p><code>$a[]="Petunia";</code></p>
<p><code>$a[]="Amanda";</code></p>
<p><code>$a[]="Raquel";</code></p>
<p><code>$a[]="Cindy";</code></p>
<p><code>$a[]="Doris";</code></p>
<p><code>$a[]="Eve";</code></p>
<p><code>$a[]="Evita";</code></p>
<p><code>$a[]="Sunniva";</code></p>
<p><code>$a[]="Tove";</code></p>
<p><code>$a[]="Unni";</code></p>
<p><code>$a[]="Violet";</code></p>
<p><code>$a[]="Liza";</code></p>
<p><code>$a[]="Elizabeth";</code></p>
<p><code>$a[]="Ellen";</code></p>
<p><code>$a[]="Wenche";</code></p>
<p><code>$a[]="Vicky";</code></p>
<p><code>//извлечение параметра q из URL</code></p>
<p><code>$q=$_GET["q"];</code></p>
<p><code>//поиск всех рекомендаций в массиве, если длина q&gt;0</code></p>
<p><code>if (strlen($q) &gt; 0)</code></p>
<p><code>{</code></p>
<p><code>$hint="";</code></p>
<p><code>for($i=0; $i&lt;count($a); $i++)</code></p>
<p><code>{</code></p>
<p><code>if (strtolower($q)==strtolower(substr($a[$i],0,strlen($q))))</code></p>
<p><code>{</code></p>
<p><code>if ($hint=="")</code></p>
<p><code>{</code></p>
<p><code>$hint=$a[$i];</code></p>
<p><code>}</code></p>
<p><code>else</code></p>
<p><code>{</code></p>
<p><code>$hint=$hint." ,".$a[$i];</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>// Вывод "нет предложений", если рекомендаций не найдено</code></p>
<p><code>// или вывод подходящих значений</code></p>
<p><code>if ($hint == "")</code></p>
<p><code>{</code></p>
<p><code>$response="нет предложений";</code></p>
<p><code>}</code></p>
<p><code>else</code></p>
<p><code>{</code></p>
<p><code>$response=$hint;</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>//вывод ответа</code></p>
<p><code>echo $response;</code></p>
<p><code>?&gt;</code></p>
<empty-line/>
<p>AJAX можно использовать для интерактивного взаимодействия с базой данных.</p>
<p>В следующем примере приложения AJAX будет показано, как Web-страница может извлекать информацию из базы данных с помощью технологии AJAX.</p>
<p>На Web-странице выводится список выбора с именами клиентов.</p>
<p>При выборе любого клиента на странице выводится связанная с ним информация из базы данных.</p>
<p>Описанный выше пример страницы содержит простую форму HTML и ссылку на сценарий JavaScript:</p>
<empty-line/>
<p>&lt;html&gt;</p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;script src="selectcustomer.js"&gt;&lt;/script&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;form&gt;</code></p>
<p><code>Выберите заказчика:</code></p>
<p><code>&lt;select name="customers" onchange="showCustomer(this.value)"&gt;</code></p>
<p><code>&lt;option value="ALFKI"&gt;Alfreds Futterkiste</code></p>
<p><code>&lt;option value="NORTS "&gt;North/South</code></p>
<p><code>&lt;option value="WOLZA"&gt;Wolski Zajazd</code></p>
<p><code>&lt;/select&gt;</code></p>
<p><code>&lt;/form&gt;</code></p>
<p><code>&lt;p&gt;</code></p>
<p><code>&lt;div id="txtHint"&gt;&lt;b&gt;Информация о заказчике будет выводиться здесь.&lt;/b&gt;&lt;/div&gt;</code></p>
<p><code>&lt;/p&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p>Как можно видеть, это просто форма HTML с раскрывающимся списком с названием "customers".</p>
<p>Параграф ниже формы содержит тег <strong>div</strong> с именем "txtHint". Тег div используется в качестве поля для заполнения получаемой с Web-сервера информацией.</p>
<p>Когда пользователь выбирает данные (имя заказчика), выполняется функция "showCustomer()". Выполнение функции запускается событием "onchange". Другими словами, каждый раз, когда пользователь изменяет значение в поле раскрывающегося списка, вызывается функция <strong>showCustomer</strong>.</p>
<p>Код JavaScript показан далее.</p>
<p>Следующий далее код JavaScript находится в файле "selectcustomer.js":</p>
<empty-line/>
<p><code>var xmlHttp</code></p>
<empty-line/>
<p><code>function showCustomer(str)</code></p>
<p><code>{</code></p>
<p><code>xmlHttp=GetXmlHttpObject()</code></p>
<p><code>if (xmlHttp==null)</code></p>
<p><code>{</code></p>
<p><code>alert ("Браузер не поддерживает запросы HTTP")</code></p>
<p><code>return</code></p>
<p><code>}</code></p>
<p><code>var url="getcustomer.asp"</code></p>
<p><code>url=url+"?q="+str</code></p>
<p><code>url=url+"&amp;sid="+Math.random()</code></p>
<p><code>xmlHttp.onreadystatechange=stateChanged</code></p>
<p><code>xmlHttp.open("GET",url,true)</code></p>
<p><code>xmlHttp.send(null)</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function stateChanged()</code></p>
<p><code>{</code></p>
<p><code>if (xmlHttp.readyState==4 || xmlHttp.readyState=="complete")</code></p>
<p><code>{</code></p>
<p><code>document.getElementById("txtHint").innerHTML=xmlHttp.responseText</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function GetXmlHttpObject()</code></p>
<p><code>{</code></p>
<p><code>var objXMLHttp=null</code></p>
<p><code>if (window.XMLHttpRequest)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new XMLHttpRequest()</code></p>
<p><code>}</code></p>
<p><code>else if (window.ActiveXObject)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new ActiveXObject("Microsoft.XMLHTTP")</code></p>
<p><code>}</code></p>
<p><code>return objXMLHttp</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Серверная страница, вызываемая сценарием JavaScript, является просто файлом ASP file с именем "getcustomer.asp".</p>
<p>Страница написана на VBScript для Информационного сервера Интернет (IIS). Ее можно легко переписать на PHP, или любой другой серверный язык.</p>
<p>Код выполняет команды SQL на базе данных и возвращает результат в виде таблицы HTML:</p>
<empty-line/>
<p><code>sql="SELECT * FROM CUSTOMERS WHERE CUSTOMERID="</code></p>
<p><code>sql=sql &amp; request.querystring("q")</code></p>
<empty-line/>
<p><code>set conn=Server.CreateObject("ADODB.Connection")</code></p>
<p><code>conn.Provider="Microsoft.Jet.OLEDB.4.0"</code></p>
<p><code>conn.Open(Server.Mappath("/db/northwind.mdb"))</code></p>
<p><code>set rs = Server.CreateObject("ADODB.recordset")</code></p>
<p><code>rs.Open sql, conn</code></p>
<empty-line/>
<p><code>response.write("&lt;table&gt;")</code></p>
<p><code>do until rs.EOF</code></p>
<p><code>for each x in rs.Fields</code></p>
<p><code>response.write("&lt;tr&gt;&lt;td&gt;&lt;b&gt;" &amp; x.name &amp; "&lt;/b&gt;&lt;/td&gt;")</code></p>
<p><code>response.write("&lt;td&gt;" &amp; x.value &amp; "&lt;/td&gt;&lt;/tr&gt;")</code></p>
<p><code>next</code></p>
<p><code>rs.MoveNext</code></p>
<p><code>loop</code></p>
<empty-line/>
<p><code>response.write("&lt;/table&gt;")</code></p>
<empty-line/>
<p>AJAX можно использовать для интерактивного взаимодействия с файлом XML.</p>
<p>В следующем далее примере приложения AJAX показано, как Web-страница может извлекать информацию из файла XML с помощью технологии AJAX.</p>
<p>На Web-странице выводится список выбора с именами исполнителей музыкальных произведений. При выборе исполнителя на странице появляется информация с описанием компакт-диска с записями этого музыканта.</p>
<p>Рассматриваемый пример содержит простую форму HTML и ссылку на код JavaScript:</p>
<empty-line/>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;script src="selectcd.js"&gt;&lt;/script&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;form&gt;</code></p>
<p><code>Выберите компакт-диск:</code></p>
<p><code>&lt;select name="cds" onchange="showCD(this.value)"&gt;</code></p>
<p><code>&lt;option value="Bob Dylan"&gt;Bob Dylan&lt;/option&gt;</code></p>
<p><code>&lt;option value="Bonnie Tyler"&gt;Bonnie Tyler&lt;/option&gt;</code></p>
<p><code>&lt;option value="Dolly Parton"&gt;Dolly Parton&lt;/option&gt;</code></p>
<p><code>&lt;/select&gt;</code></p>
<p><code>&lt;/form&gt;</code></p>
<p><code>&lt;p&gt;</code></p>
<p><code>&lt;div id="txtHint"&gt;&lt;b&gt;Здесь выводится информация о компакт-диске.&lt;/b&gt;&lt;/div&gt;</code></p>
<p><code>&lt;/p&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p>Как можно видеть, это простая форма HTML с простым раскрывающимся списком выбора с именем "cds".</p>
<p>Параграф ниже формы содержит тег <strong>div</strong> с именем "txtHint". Тег div используется в качестве поля для заполнения информацией, получаемой с Web-сервера.</p>
<p>Когда пользователь делает свой выбор, выполняется функция с именем "showCD". Выполнение функции запускается событием "onchange". Другими словами, каждый раз, когда пользователь изменяет значение в поле раскрывающегося списка, вызывается функция <strong>showCD</strong>.</p>
<p>Код JavaScript показан далее.</p>
<p>Следующий далее код JavaScript находится в файле "selectcd.js":</p>
<empty-line/>
<p><code>var xmlHttp</code></p>
<empty-line/>
<p><code>function showCD(str)</code></p>
<p><code>{</code></p>
<p><code>xmlHttp=GetXmlHttpObject()</code></p>
<p><code>if (xmlHttp==null)</code></p>
<p><code>{</code></p>
<p><code>alert ("Браузер не поддерживает запросы HTTP")</code></p>
<p><code>return</code></p>
<p><code>}</code></p>
<p><code>var url="getcd.asp"</code></p>
<p><code>url=url+"?q="+str</code></p>
<p><code>url=url+"&amp;sid="+Math.random()</code></p>
<p><code>xmlHttp.onreadystatechange=stateChanged</code></p>
<p><code>xmlHttp.open("GET",url,true)</code></p>
<p><code>xmlHttp.send(null)</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function stateChanged()</code></p>
<p><code>{</code></p>
<p><code>if (xmlHttp.readyState==4 || xmlHttp.readyState=="complete")</code></p>
<p><code>{</code></p>
<p><code>document.getElementById("txtHint").innerHTML=xmlHttp.responseText</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>function GetXmlHttpObject()</code></p>
<p><code>{</code></p>
<p><code>var objXMLHttp=null</code></p>
<p><code>if (window.XMLHttpRequest)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new XMLHttpRequest()</code></p>
<p><code>}</code></p>
<p><code>else if (window.ActiveXObject)</code></p>
<p><code>{</code></p>
<p><code>objXMLHttp=new ActiveXObject("Microsoft.XMLHTTP")</code></p>
<p><code>}</code></p>
<p><code>return objXMLHttp</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Серверная страница, вызываемая кодом JavaScript, будет простым файлом ASP с именем "getcd.asp".</p>
<p>Страница написана на VBScript для Информационного сервера Интернет (IIS). Ее можно легко переписать на PHP, или любом другом серверном языке.</p>
<p>Код выполняет запрос на файле XML и возвращает результат в виде HTML.</p>
<empty-line/>
<p>q=request.querystring("q")</p>
<empty-line/>
<p><code>set xmlDoc=Server.CreateObject("Microsoft.XMLDOM")</code></p>
<p><code>xmlDoc.async="false"</code></p>
<p><code>xmlDoc.load(Server.MapPath("cd_catalog.xml"))</code></p>
<empty-line/>
<p><code>set nodes=xmlDoc.selectNodes("CATALOG/CD[ARTIST='" &amp; q &amp; "']")</code></p>
<empty-line/>
<p><code>for each x in nodes</code></p>
<p><code>for each y in x.childnodes</code></p>
<p><code>response.write("&lt;b&gt;" &amp; y.nodename &amp; ":&lt;/b&gt; ")</code></p>
<p><code>response.write(y.text)</code></p>
<p><code>response.write("&lt;br /&gt;")</code></p>
<p><code>next</code></p>
<p><code>next</code></p>
<empty-line/>
<p>Объект <strong>XMLHttpRequest</strong> делает возможной технологию AJAX.</p>
<p>Чтобы создавать Web-приложения AJAX, необходимо хорошо знать объект JavaScript, называемый <strong>XMLHttpRequest</strong>.</p>
<p>Объект <strong>XMLHttpRequest</strong> является ключевым понятием технологии AJAX. Он был доступен с момента появления в июле 2000 браузера Internet Explorer 5.5, но не был полностью понят до 2005 года, когда начались разговоры об AJAX и Web 2.0.</p>
<p>Ниже представлены некоторые методы и свойства этого объекта, с которыми необходимо быть знакомым.</p>
<p>Различные браузеры используют для создания объекта <strong>XMLHttpRequest</strong> различные методы.</p>
<p>Internet Explorer использует ActiveXObject.</p>
<p>Другие браузеры используют встроенный в JavaScript объект, называемый <strong>XMLHttpRequest</strong>.</p>
<p>Вот простейший код, который можно использовать, чтобы обойти эту проблему.</p>
<empty-line/>
<p><code>var XMLHttp=null</code></p>
<empty-line/>
<p><code>if (window.XMLHttpRequest)</code></p>
<p><code>{</code></p>
<p><code>XMLHttp=new XMLHttpRequest()</code></p>
<p><code>}</code></p>
<p><code>else if (window.ActiveXObject)</code></p>
<p><code>{</code></p>
<p><code>XMLHttp=new ActiveXObject("Microsoft.XMLHTTP")</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Сначала создается переменная <strong>XMLHttp</strong> для использования в качестве объекта <strong>XMLHttpRequest</strong>. Ее значение задается как <strong>null</strong>.</p>
<p>Затем проверяется, доступен ли объект <strong>window.XMLHttpRequest</strong>. Этот объект доступен в более новых версиях браузеров, таких как Firefox, Mozilla, и Opera.</p>
<p>Если объект доступен, то он используется для создания нового объекта.</p>
<empty-line/>
<p>XMLHttp=new XMLHttpRequest().</p>
<empty-line/>
<p>Если он не доступен, то проверяется, доступен ли объект <strong>window.ActiveXObject</strong>. Этот объект будет доступен в браузере Internet Explorer версии 5.5 и выше.</p>
<p>Если этот объект доступен, то он используется для создания нового объекта:</p>
<empty-line/>
<p>XMLHttp=new ActiveXObject().</p>
<empty-line/>
<p>Некоторые программисты предпочтут использовать самую новую и быструю версию объекта <strong>XMLHttpRequest</strong>.</p>
<p>Следующий пример пытается использовать самую последнюю версию объекта "Msxml2.XMLHTTP" компании Microsoft, доступную в Internet Explorer 6, прежде чем обратиться к объекту "Microsoft.XMLHTTP", доступному в Internet Explorer 5.5 и выше.</p>
<empty-line/>
<p><code>var XMLHttp=null</code></p>
<p><code>try</code></p>
<p><code>{</code></p>
<p><code>XMLHttp=new ActiveXObject("Msxml2.XMLHTTP")</code></p>
<p><code>}</code></p>
<p><code>catch(e)</code></p>
<p><code>{</code></p>
<p><code>try</code></p>
<p><code>{</code></p>
<p><code>XMLHttp=new ActiveXObject("Microsoft.XMLHTTP")</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/>
<p><code>if (XMLHttp==null)</code></p>
<p><code>{</code></p>
<p><code>XMLHttp=new XMLHttpRequest()</code></p>
<p><code>}</code></p>
<empty-line/>
<p>Сначала создается переменная <strong>XMLHttp</strong> для использования в качестве объекта <strong>XMLHttpRequest</strong>. Ее значение задается как <strong>null</strong>.</p>
<p>Затем делается попытка создания объекта способом компании Microsoft, доступным в Internet Explorer 6 и более поздних версиях:</p>
<empty-line/>
<p><code>XMLHttp=new ActiveXObject("Msxml2.XMLHTTP")</code></p>
<empty-line/>
<p>Если это порождает ошибку, то используется старый способ (Internet Explorer 5.5):</p>
<empty-line/>
<p><code>XMLHttp=new ActiveXObject("Microsoft.XMLHTTP")</code></p>
<empty-line/>
<p>Если <strong>XMLHttp</strong> по прежнему имеет значение <strong>null</strong>, то делается попытка создания объекта "стандартным" способом:</p>
<empty-line/>
<p><code>XMLHttp=new XMLHttpRequest()</code></p>
<empty-line/>
<p><strong>Метод open()</strong></p>
<p>Метод <strong>open()</strong> создает запрос для Web-сервера.</p>
<p><strong>Метод send()</strong></p>
<p>Метод <strong>send()</strong> посылает запрос серверу.</p>
<p><strong>Метод abort()</strong></p>
<p>Метод <strong>abort()</strong> отменяет текущий запрос к серверу.</p>
<p>Свойство <strong>readyState</strong> определяет текущее состояние объекта <strong>XMLHttpRequest</strong>.</p>
<p>В таблице показаны возможные значения свойства <strong>readyState</strong>:</p>
<empty-line/>
<table><tr>
<th>Состояние</th>
<th>Описание</th>
</tr><tr>
<td>0</td>
<td>Запрос не инициализирован</td>
</tr><tr>
<td>1</td>
<td>Запрос создан</td>
</tr><tr>
<td>2</td>
<td>Запрос послан</td>
</tr><tr>
<td>3</td>
<td>Запрос обрабатывается</td>
</tr><tr>
<td>4</td>
<td>Запрос завершен</td>
</tr></table>
<empty-line/>
<p><strong>readyState=0</strong> после создания объекта <strong>XMLHttpRequest</strong>, но до вызова метода <strong>open()</strong>.</p>
<p><strong>readyState=1</strong> после вызова метода <strong>open()</strong>, но до вызова метода <strong>send()</strong>.</p>
<p><strong>readyState=2</strong> после вызова метода <strong>send()</strong>.</p>
<p><strong>readyState=3</strong> после того, как браузер соединится с сервером, но до завершения сервером ответа.</p>
<p><strong>readyState=4</strong> после завершения запроса и полного получения всех данных ответа с сервера.</p>
<p>Различные браузеры используют свойство состояния готовности по-разному. Не стоит рассчитывать, что все браузеры будут сообщать обо всех состояниях. Некоторые не сообщают о состоянии 0 и 1.</p>
<p>Для приложений AJAX представляет интерес фактически только состояние 4. Те есть, когда запрос завершен, и можно использовать полученные данные.</p>
<p>Свойство <strong>responseText</strong> содержит присланный сервером текст.</p>
</section>
<section>
<title>
<p><emphasis>Дополнение II.</emphasis> Учебное руководство по XHTML</p>
</title>
<p>Язык XHTML является более строгой и четкой версией языка разметки HTML.</p>
<p>В данном руководстве рассмотрены различия между HTML и XHTML, а также показано, как преобразовать Web-сайт на использование XHTML.</p>
<p>Язык XHTML является более строгой и четкой версией языка HTML.</p>
<p>Для понимания изложенного материала необходимо знать язык HTML и основы создания Web-страниц.</p>
<p>XHTML является сокращением от английского EXtensible HyperText Markup Language, что означает "Расширяемый язык разметки гипертекста".</p>
<p>XHTML предназначен для замены HTML.</p>
<p>XHTML почти совпадает с HTML 4.01.</p>
<p>XHTML является более строгой и четкой версией языка HTML.</p>
<p>XHTML является языком HTML, определенным как приложение XML.</p>
<p>XHTML одобрен в качестве Рекомендации консорциумом W3C.</p>
<p>XHTML 1.0 был одобрен как Рекомендация W3C 26 января 2000 г..</p>
<p>W3C определяет XHTML как последнюю версию HTML. XHTML будет постепенно заменять HTML.</p>
<p>Язык XHTML совместим с HTML 4.01.</p>
<p>Все новые браузеры поддерживают XHTML.</p>
<p>XHTML является переработкой HTML 4.01 в соответствии с XML, и может сразу использоваться существующими браузерами при соблюдении нескольких простых правил.</p>
<p>Данное руководство рассматривает:</p>
<p><strong>[x]</strong> Почему необходимо использовать XHTML</p>
<p><strong>[x]</strong> Синтаксис XHTML</p>
<p><strong>[x]</strong> Как преобразовать сайт на XHTML</p>
<p><strong>[x]</strong> Проверка XHTML</p>
<p><strong>[x]</strong> Модуляризация XHTML</p>
<p>XHTML является объединением HTML и XML (EXtensible Markup Language – Расширяемого языка разметки).</p>
<p>XHTML состоит из всех элементов HTML 4.01, объединенных с синтаксисом XML.</p>
<p>В настоящее время многие страницы в Интернет содержат "плохой" код HTML.</p>
<p>Следующий код HTML будет нормально работать при просмотре в браузере, даже хотя он не полностью следует правилам HTML:</p>
<empty-line/>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;title&gt;Это плохой код HTML&lt;/title&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;h1&gt;Плохой код HTML</code></p>
<p><code>&lt;/body&gt;</code></p>
<empty-line/>
<p>XML является языком разметки, в котором каждый элемент должен быть правильно размечен, что приводит к "грамматически-правильным" ("well-formed") документам.</p>
<p>Язык XML предназначен для описания данных, а язык HTML создан для представления данных.</p>
<p>На современном рынке представлены различные технологии браузеров, одни браузеры предназначены для использования Интернет на компьютерах, другие для использования Интернет на мобильных телефонах и c помощью карманных коммуникаторов. Последние устройства имеют недостаточно ресурсов или мощности для интерпретации "плохого" языка разметки.</p>
<p>Объединяя сильные стороны HTML и XML, мы получаем язык разметки, который будет полезен сегодня и в будущем -- XHTML.</p>
<p>Страницы XHTML можно читать с помощью любых устройств, которые поддерживают XML. Пока весь мир не перейдет на использование поддерживающих XML браузеров, XHTML предоставляет возможность сейчас писать "синтаксически-правильные" документы, которые можно использовать во всех браузерах.</p>
<p>XHTML можно начать использовать просто строго следуя правилам HTML.</p>
<p>XHTML не очень существенно отличается от стандарта HTML 4.01.</p>
<p>Поэтому хорошим началом будет приведение кода к стандарту 4.01.</p>
<p>Кроме того, необходимо писать код HTML символами нижнего регистра, и никогда не пропускать завершающие теги (такие как <strong>&lt;/p&gt;</strong>).</p>
<p>Вот собственно и все. Удачного кодирования!</p>
<p>Элементы XHTML должны быть правильно вложены</p>
<p>Элементы XHTML всегда должны быть замкнутыми</p>
<p>Элементы XHTML должны записываться в нижнем регистре</p>
<p>Документы XHTML должны иметь один корневой элемент</p>
<p>В HTML некоторые элементы могут вкладываться друг в друга некорректно, например как в случае: <strong>&lt;b&gt;&lt;i&gt;Этот текст жирный и наклонный&lt;/b&gt;&lt;/i&gt;</strong></p>
<p>В XHTML все элементы должны правильно вкладываться друг в друга, например: <strong>&lt;b&gt;&lt;i&gt;Этот текст жирный и наклонный&lt;/i&gt;&lt;/b&gt;</strong></p>
<p><strong>Примечание:</strong> Достаточно часто при создании вложенных списков забывают о том, что внутренний список должен находится между тегами <strong>&lt;li&gt;</strong> и <strong>&lt;/li&gt;</strong>.</p>
<p>Неправильно:</p>
<empty-line/>
<p><code>&lt;ul&gt;</code></p>
<p><code>&lt;li&gt;Кофе&lt;/li&gt;</code></p>
<p><code>&lt;li&gt;Чай</code></p>
<p><code>&lt;ul&gt;</code></p>
<p><code>&lt;li&gt;Черный чай&lt;/li&gt;</code></p>
<p><code>&lt;li&gt;Зеленый чай&lt;/li&gt;</code></p>
<p><code>&lt;/ul&gt;</code></p>
<p><code>&lt;li&gt;Молоко&lt;/li&gt;</code></p>
<p><code>&lt;/ul&gt;</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>&lt;ul&gt;</code></p>
<p><code>&lt;li&gt;Кофе&lt;/li&gt;</code></p>
<p><code>&lt;li&gt;Чай</code></p>
<p><code>&lt;ul&gt;</code></p>
<p><code>&lt;li&gt;Черный чай&lt;/li&gt;</code></p>
<p><code>&lt;li&gt;Зеленый чай&lt;/li&gt;</code></p>
<p><code>&lt;/ul&gt;</code></p>
<p><code>&lt;/li&gt;</code></p>
<p><code>&lt;li&gt;Молоко&lt;/li&gt;</code></p>
<p><code>&lt;/ul&gt;</code></p>
<empty-line/>
<p>Обратите внимание, что в примере "правильного" кода вставлен тег <strong>&lt;/li&gt;</strong> после тега <strong>&lt;/ul&gt;</strong>.</p>
<p>Непустые элементы должны иметь замыкающий тег.</p>
<p>Неправильно:</p>
<empty-line/>
<p><code>&lt;p&gt;Это -- параграф</code></p>
<p><code>&lt;p&gt;Это -- еще один параграф</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>&lt;p&gt;Это -- параграф &lt;/p&gt;</code></p>
<p><code>&lt;p&gt;Это -- еще один параграф &lt;/p&gt;</code></p>
<empty-line/>
<p>Пустые элементы должны иметь замыкающий тег или начальный тег должен заканчиваться символами <strong>/&gt;</strong>.</p>
<p>Неправильно:</p>
<empty-line/>
<p><code>Разрыв строки: &lt;br&gt;</code></p>
<p><code>Горизонтальная линия: &lt;hr&gt;</code></p>
<p><code>Изображение: &lt;img src="happy.gif" alt="Веселое лицо "&gt;</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>Разрыв строки: &lt;br /&gt;</code></p>
<p><code>Горизонтальная линия: &lt;hr /&gt;</code></p>
<p><code>Изображение: &lt;img src="happy.gif" alt="Веселое лицо" /&gt;</code></p>
<empty-line/>
<p>Спецификация XHTML определяет, что имена и атрибуты тегов должны записываться в нижнем регистре.</p>
<p>Неправильно:</p>
<empty-line/>
<p><code>&lt;BODY&gt;</code></p>
<p><code>&lt;P&gt;Параграф &lt;/P&gt;</code></p>
<p><code>&lt;/BODY&gt;</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;p&gt;Параграф &lt;/p&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<empty-line/>
<p>Все элементы XHTML должны быть вложены в корневой элемент <strong>&lt;html&gt;</strong>. Все другие элементы могут иметь вложенные элементы (потомков). Вложенные элементы должны быть парными и правильно вкладываться в свой родительский элемент. Общая структура документа имеет следующий вид:</p>
<empty-line/>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt; ... &lt;/head&gt;</code></p>
<p><code>&lt;body&gt; ... &lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p>При записи документа XHTML требуется использовать четкий синтаксис HTML.</p>
<p><strong>[x]</strong> Имена атрибутов должны записываться в нижнем регистре</p>
<p><strong>[x]</strong> Значения атрибутов должны заключаться в кавычки</p>
<p><strong>[x]</strong> Минимизация атрибутов запрещена</p>
<p><strong>[x]</strong> Атрибут <strong>id</strong> заменяет атрибут name</p>
<p><strong>[x]</strong> DTD XHTML определяет обязательные элементы</p>
<p>Неправильно:</p>
<empty-line/>
<p><code>&lt;table WIDTH="100%"&gt;</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>&lt;table width="100%"&gt;</code></p>
<empty-line/>
<p>Неправильно:</p>
<empty-line/>
<p><code>&lt;table width=100%&gt;</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>&lt;table width="100%"&gt;</code></p>
<empty-line/>
<p>Неправильно:</p>
<empty-line/>
<p><code>&lt;input checked&gt;</code></p>
<p><code>&lt;input readonly&gt;</code></p>
<p><code>&lt;input disabled&gt;</code></p>
<p><code>&lt;option selected&gt;</code></p>
<p><code>&lt;frame noresize&gt;</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>&lt;input checked="checked" /&gt;</code></p>
<p><code>&lt;input readonly="readonly" /&gt;</code></p>
<p><code>&lt;input disabled="disabled" /&gt;</code></p>
<p><code>&lt;option selected="selected" /&gt;</code></p>
<p><code>&lt;frame noresize="noresize" /&gt;</code></p>
<empty-line/>
<p>Ниже представлен список минимизированных атрибутов HTML и их запись в XHTML.</p>
<empty-line/>
<table>
<tr>
<th>HTML</th>
<th>XHTML</th>
</tr>
<tr>
<td><strong>compact</strong></td>
<td><strong>compact="compact"</strong></td>
</tr>
<tr>
<td><strong>checked declare</strong></td>
<td><strong>checked="checked" declare="declare"</strong></td>
</tr>
<tr>
<td><strong>readonly</strong></td>
<td><strong>readonly="readonly"</strong></td>
</tr>
<tr>
<td><strong>disabled</strong></td>
<td><strong>disabled="disabled"</strong></td>
</tr>
<tr>
<td><strong>selected</strong></td>
<td><strong>selected="selected"</strong></td>
</tr>
<tr>
<td><strong>defer</strong></td>
<td><strong>defer="defer"</strong></td>
</tr>
<tr>
<td><strong>ismap</strong></td>
<td><strong>ismap="ismap"</strong></td>
</tr>
<tr>
<td><strong>nohref</strong></td>
<td><strong>nohref="nohref"</strong></td>
</tr>
<tr>
<td><strong>noshade</strong></td>
<td><strong>noshade="noshade"</strong></td>
</tr>
<tr>
<td><strong>nowrap</strong></td>
<td><strong>nowrap="nowrap"</strong></td>
</tr>
<tr>
<td><strong>multiple</strong></td>
<td><strong>multiple="multiple"</strong></td>
</tr>
<tr>
<td><strong>noresize</strong></td>
<td><strong>noresize="noresize"</strong></td>
</tr>
</table>
<empty-line/>
<p>HTML 4.01 определяет атрибут <strong>name</strong> для элементов <strong>a, applet, frame, iframe, img,</strong> и <strong>map</strong>. В XHTML атрибут <strong>name</strong> исключен. Вместо него используется атрибут <strong>id</strong>.</p>
<p>Неправильно:</p>
<empty-line/>
<p><code>&lt;img src="picture.gif" name="рис. 1" /&gt;</code></p>
<empty-line/>
<p>Правильно:</p>
<empty-line/>
<p><code>&lt;img src="picture.gif" id="рис. 1" /&gt;</code></p>
<empty-line/>
<p><strong>Примечание:</strong> Для взаимодействия со старыми браузерами в течение некоторого времени необходимо будет использовать оба атрибута <strong>name</strong> и <strong>id</strong>, с одинаковыми значениями атрибутов, например: <strong>&lt;img src="picture.gif" id="рис. 1" name="рис. 1" /&gt;</strong>.</p>
<p>Для совместимости XHTML с современными браузерами, необходимо добавить дополнительный пробел перед символом "/".</p>
<p>Атрибут <strong>lang</strong> применим почти к любому элементу XHTML. Он определяет язык содержимого внутри элемента.</p>
<p>Если в каком-то элементе используется атрибут <strong>lang</strong>, то необходимо добавить атрибут <strong>xml:lang</strong>, например: <strong>&lt;div lang="fr" xml:lang="fr"&gt;Bonjour, madam!&lt;/div&gt;</strong>.</p>
<p>Все документы XHTML должны иметь объявление DOCTYPE. Также должны присутствовать элементы <strong>html, head и body</strong>, а внутри элемента <strong>head</strong> должен присутствовать элемент <strong>title</strong>.</p>
<p>Шаблон минимального документа XHTML имеет следующий вид:</p>
<empty-line/>
<p><code>&lt;!DOCTYPE Здесь определяется тип документа&gt;</code></p>
<p><code>&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;title&gt;Здесь задается заголовок &lt;/title&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p><strong>Примечание:</strong> Объявление DOCTYPE не является частью самого документа XHTML. Это объявление не является элементом XHTML и не должно иметь закрывающий тег.</p>
<p><strong>Примечание:</strong> Атрибут xmlns в теге <strong>&lt;html&gt;</strong> является в XHTML обязательным. Однако программа проверки (валидатор) на сайте w3.org не высказывает претензий, когда этот атрибут отсутствует в документе XHTML. Это обусловлено тем, что атрибут "xmlns=http://www.w3.org/1999/xhtml" имеет фиксированное значение и будет добавлен в тег <strong>&lt;html&gt;</strong>, даже если он не был включен.</p>
<p>В следующем разделе представлена дополнительная информация об определении типа документа XHTML.</p>
<p>Стандарт XHTML определяет три определения типа документа (Document Type Definitions – DTD).</p>
<p>Наиболее распространенным является XHTML Transitional (Переходный).</p>
<p>Документ XHTML состоит из трех основных частей:</p>
<p>Тип документа DOCTYPE</p>
<p>Заголовок (Head)</p>
<p>Тело (Body)</p>
<p>Базовая структура документа имеет следующий вид:</p>
<empty-line/>
<p><code>&lt;!DOCTYPE ...&gt;</code></p>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;title&gt;... &lt;/title&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt; ... &lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p>Объявление DOCTYPE всегда должно присутствовать в первой строке документа XHTML.</p>
<p>Это простой (минимальный) документ XHTML:</p>
<empty-line/>
<p><code>&lt;!DOCTYPE html</code></p>
<p><code>PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</code></p>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;title&gt;простой документ &lt;/title&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;p&gt;простой параграф &lt;/p&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p>Объявление DOCTYPE определяет тип документа:</p>
<empty-line/>
<p><code>&lt;!DOCTYPE html</code></p>
<p><code>PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</code></p>
<empty-line/>
<p>Оставшаяся часть документа выглядит как HTML:</p>
<empty-line/>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;title&gt;простой документ &lt;/title&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;p&gt; простой параграф &lt;/p&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p><strong>[x]</strong> DTD определяет синтаксис Web-страницы на SGML.</p>
<p><strong>[x]</strong> DTD используется приложениями SGML, такими как HTML, для определения правил, которые применяют при разметке документов определенного типа, включая множество объявлений элементов и сущностей.</p>
<p><strong>[x]</strong> XHTML задан в определении типа документа SGML или 'DTD'.</p>
<p><strong>[x]</strong> DTD XHTML описывает точным, понятным для компьютера языком допустимый синтаксис и грамматику разметки XHTML.</p>
<p>В настоящее время имеется три типа документов XHTML:</p>
<p><strong>[x]</strong> STRICT</p>
<p><strong>[x]</strong> TRANSITIONAL</p>
<p><strong>[x]</strong> FRAMESET</p>
<p>XHTML 1.0 определяет три типа документов XML, которые соответствуют трем DTD: Strict, Transitional, и Frameset.</p>
<empty-line/>
<p><code>&lt;!DOCTYPE html</code></p>
<p><code>PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</code></p>
<empty-line/>
<p>Это определение DTD используется, когда требуется получить действительно четкую разметку, не имеющую в представлении никакого беспорядка. Оно используется вместе с каскадными таблицами стилей.</p>
<empty-line/>
<p><code>&lt;!DOCTYPE html</code></p>
<p><code>PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</code></p>
<empty-line/>
<p>Используйте это определение, когда надо воспользоваться средствами представления HTML, и когда необходимо обеспечить поддержку для браузеров, которые не понимают каскадные таблицы стилей.</p>
<empty-line/>
<p><code>&lt;!DOCTYPE html</code></p>
<p><code>PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;</code></p>
<empty-line/>
<p>Укажите это определение, когда будут использоваться фреймы HTML, чтобы разделить окно браузера на два или большее количество фреймов.</p>
<p>Чтобы преобразовать Web-сайт с языка HTML на XHTML, необходимо знать правила синтаксиса XHTML, которые были рассмотрены выше. Затем необходимо выполнить следующие действия (в указанном порядке):</p>
<p>В качестве первой строки каждой страницы добавляют следующее объявление DOCTYPE:</p>
<empty-line/>
<p><code>&lt;!DOCTYPE html PUBLIC</code></p>
<p><code>"-//W3C//DTD XHTML 1.0 Transitional//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</code></p>
<empty-line/>
<p>Лучше использовать сначала переходное определение DTD (Transitional). Можно выбрать и строгое определение DTD (Strict), но оно немного слишком "строгое" на начальном этапе, и ему труднее соответствовать.</p>
<p>Web-cтраницы должны иметь объявление DOCTYPE, если желательно, чтобы они были определены как правильные согласно XHTML.</p>
<p>Надо помнить, однако, что более новые браузеры (такие как Internet Explorer 6) могут обрабатывать документ по-разному, в зависимости от объявления <strong>&lt;!DOCTYPE&gt;</strong>. Если браузер читает документ с DOCTYPE, то он может интерпретировать документ как "правильный". Плохо сформированный XHTML может выводиться иначе, чем при отсутствии DOCTYPE.</p>
<p>Так как XHTML различает регистр символов, и поскольку XHTML допускает имена тегов и атрибутов HTML только в нижнем регистре, то необходимо выполнить глобальный поиск и замену всех тегов в верхнем регистре тегами, записанными в нижнем регистре. Аналогичную процедуру необходимо выполнить также для имен атрибутов.</p>
<p>Так как рекомендация W3C для XTML 1.0 говорит, что значения всех атрибутов должны быть заключены в кавычки, то необходимо проверить все Web-страницы, чтобы значения всех атрибутов были правильно заключены в кавычки. Это трудоемкая работа, поэтому рекомендуется в будущем никогда не забывать использовать кавычки для значений атрибутов.</p>
<p>В XHTML пустые теги не разрешены. Теги <strong>&lt;hr&gt;</strong> и <strong>&lt;br&gt;</strong> должны быть заменены соответственно на <strong>&lt;hr /&gt;</strong> и <strong>&lt;br /&gt;</strong>.</p>
<p>Это создает проблему с браузером Netscape, который неправильно интерпретирует тег <strong>&lt;br/&gt;</strong>. Но к счастью, по неизвестной причине, замена его на <strong>&lt;br /&gt;</strong> прекрасно работает. В этом случае также необходимо выполнить глобальный поиск и замену соответствующих тегов.</p>
<p>Некоторые другие теги (такие как тег <strong>&lt;img&gt;</strong>) страдают от такой же проблемы. В данном случае можно не использовать тег замыкания <strong>&lt;/img&gt;</strong>, а добавить <strong>/&gt;</strong> в конце тега.</p>
<p>После выполнения всех преобразований все имеющиеся страницы проверяются согласно официальному DTD W3C с помощью следующей ссылки на XHTML Validator (<a l:href="http://validator.w3.org/check/referer">http://validator.w3.org/check/referer</a>). Возможные не выявленные на начальном этапе ошибки надо будет отредактировать вручную. Наиболее распространенной ошибкой бывает отсутствие в списках тегов замыкающего <strong>&lt;/li&gt;</strong>.</p>
<p>Имеются ли какие-либо специальные инструментальные средства для преобразования? Да, можно использовать утилиту TIDY.</p>
<p>Бесплатная утилита Дейва Рагетта HTML TIDY (<a l:href="http://www.w3.org/People/Raggett/tidy/">http://www.w3.org/People/Raggett/tidy/</a>) предназначена для проверки кода HTML. Она также отлично справляется с трудночитаемыми разметками документов, созданными специальными редакторами HTML и инструментальными средствами конвертации, и может помочь определить места кода, требующие дополнительного внимания, чтобы сделать Web-страницы более доступными для людей с физическими недостатками.</p>
<p>Документ XHTML проверяется согласно Определению типа документа.</p>
<p>Документ XHTML проверяют на соответствие определению типа документа (DTD). Прежде чем можно будет проверить файл XHTML, необходимо добавить в качестве первой строки правильный DTD.</p>
<p>Strict DTD содержит элементы и атрибуты, которые не были исключены и не связаны с фреймами:</p>
<empty-line/>
<p><code>!DOCTYPE html PUBLIC</code></p>
<p><code>"-//W3C//DTD XHTML 1.0 Strict//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</code></p>
<empty-line/>
<p><code>Transitional DTD содержит все из Strict DTD плюс исключенные элементы и атрибуты:</code></p>
<empty-line/>
<p><code>!DOCTYPE html PUBLIC</code></p>
<p><code>"-//W3C//DTD XHTML 1.0 Transitional//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</code></p>
<empty-line/>
<p><code>Frameset DTD содержит все из Transitional DTD плюс фреймы:</code></p>
<empty-line/>
<p><code>!DOCTYPE html PUBLIC</code></p>
<p><code>"-//W3C//DTD XHTML 1.0 Frameset//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"</code></p>
<empty-line/>
<p>Простой документ XHTML имеет следующий вид:</p>
<empty-line/>
<p>&lt;!DOCTYPE html</p>
<p><code>PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</code></p>
<p><code>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</code></p>
<p><code>&lt;html&gt;</code></p>
<p><code>&lt;head&gt;</code></p>
<p><code>&lt;title&gt;простой документ &lt;/title&gt;</code></p>
<p><code>&lt;/head&gt;</code></p>
<p><code>&lt;body&gt;</code></p>
<p><code>&lt;p&gt;простой параграф &lt;/p&gt;</code></p>
<p><code>&lt;/body&gt;</code></p>
<p><code>&lt;/html&gt;</code></p>
<empty-line/>
<p>Модель модуляризации XHTML определяет модули XHTML.</p>
<p>XHTML является простым, но большим языком. XHTML содержит большинство функций, которые могут понадобиться Web-разработчику.</p>
<p>Для некоторых целей XHTML является слишком большим и сложным, а для других целей он слишком прост.</p>
<p>Разделяя XHTML на модули, консорциум W3C создал небольшие и строго определенные множества элементов XHTML, которые можно использовать отдельно для простых устройств, а также в соединении с другими стандартами XML в больших и более сложных приложениях.</p>
<p>Используя модульность XHTML, разработчики приложений могут:</p>
<p><strong>[x]</strong> Выбирать элементы, которые будут поддерживаться устройством, используя стандартные строительные блоки XHTML.</p>
<p><strong>[x]</strong> Добавлять в XHTML расширения, используя XML, и не нарушая стандарт XHTML.</p>
<p><strong>[x]</strong> Упрощать XHTML для таких устройств, как карманные компьютеры-коммуникаторы, мобильные телефоны, ТВ устройства, и устройства бытовой техники.</p>
<p><strong>[x]</strong> Расширять XHTML для сложных приложений, добавляя новые функции XML (такие как MathML, SVG, Voice and Multimedia).</p>
<p><strong>[x]</strong> Определять профили XHTML, такие как XHTML Basic (подмножество XHTML для мобильных устройств).</p>
<p>Консорциум W3C разделил определение XHTML на 28 модулей:</p>
<empty-line/>
<table>
<tr>
<th>Имя модуля</th>
<th>Описание</th>
</tr>
<tr>
<td>модуль <strong>Applet</strong></td>
<td>Определяет исключенный элемент <strong>applet</strong></td>
</tr>
<tr>
<td>модуль <strong>Base</strong></td>
<td>Определяет элемент <strong>base</strong></td>
</tr>
<tr>
<td>модуль <strong>Basic Forms</strong></td>
<td>Определяет базовые элементы форм</td>
</tr>
<tr>
<td>модуль <strong>Basic Tables</strong></td>
<td>Определяет базовые элементы таблиц</td>
</tr>
<tr>
<td>модуль <strong>Bi-directional Text</strong></td>
<td>Определяет элемент <strong>bdo</strong></td>
</tr>
<tr>
<td>модуль <strong>Client Image Map</strong></td>
<td>Определяет элементы карт-изображений на стороне браузера</td>
</tr>
<tr>
<td>модуль <strong>Edit</strong></td>
<td>Определяет элементы редактирования <strong>del</strong> и <strong>ins</strong></td>
</tr>
<tr>
<td>модуль <strong>Forms</strong></td>
<td>Определяет все элементы, используемые в формах</td>
</tr>
<tr>
<td>модуль <strong>Frames</strong></td>
<td>Определяет элементы, связанные с фреймами</td>
</tr>
<tr>
<td>модуль <strong>Hypertext</strong></td>
<td>Определяет элемент <strong>a</strong></td>
</tr>
<tr>
<td>модуль <strong>Iframe</strong></td>
<td>Определяет элемент <strong>iframe</strong></td>
</tr>
<tr>
<td>модуль <strong>Image</strong></td>
<td>Определяет элемент <strong>img</strong></td>
</tr>
<tr>
<td>модуль <strong>Intrinsic Events</strong></td>
<td>Определяет атрибуты событий, такие как <strong>onblur</strong> и <strong>onchange</strong></td>
</tr>
<tr>
<td>модуль <strong>Legacy</strong></td>
<td>Определяет исключенные элементы и атрибуты</td>
</tr>
<tr>
<td>модуль <strong>Link</strong></td>
<td>Определяет элемент <strong>link</strong></td>
</tr>
<tr>
<td>модуль <strong>List</strong></td>
<td>Определяет элементы списка <strong>li, ul, dd, dt</strong>, и <strong>dl</strong></td>
</tr>
<tr>
<td>модуль <strong>Metainformation</strong></td>
<td>Определяет элемент <strong>meta</strong></td>
</tr>
<tr>
<td>модуль <strong>Name Identification</strong></td>
<td>Определяет исключенный атрибут <strong>name</strong></td>
</tr>
<tr>
<td>модуль <strong>Object</strong></td>
<td>Определяет элементы <strong>object</strong> и <strong>param</strong></td>
</tr>
<tr>
<td>модуль <strong>Presentation</strong></td>
<td>Определяет элементы представления, такие как <strong>b</strong> и <strong>i</strong></td>
</tr>
<tr>
<td>модуль <strong>Scripting</strong></td>
<td>Определяет элементы <strong>script</strong> и <strong>noscript</strong></td>
</tr>
<tr>
<td>модуль <strong>Server Image Map</strong></td>
<td>Определяет элементы карт-изображений на сервере</td>
</tr>
<tr>
<td>модуль <strong>Structure</strong></td>
<td>Определяет элементы <strong>html, head, title</strong> и <strong>body</strong></td>
</tr>
<tr>
<td>модуль <strong>Style Attribute</strong></td>
<td>Определяет атрибут <strong>style</strong></td>
</tr>
<tr>
<td>модуль <strong>Style Sheet</strong></td>
<td>Определяет элемент <strong>style</strong></td>
</tr>
<tr>
<td>модуль <strong>Tables</strong></td>
<td>Определяет элементы, используемые в таблицах</td>
</tr>
<tr>
<td>модуль <strong>Target</strong></td>
<td>Определяет атрибут <strong>target</strong></td>
</tr>
<tr>
<td>модуль <strong>Text</strong></td>
<td>Определяет элементы контейнера текста, такие как <strong>p</strong> и <strong>h1</strong></td>
</tr>
</table>
<empty-line/>
<p>Исключенные элементы не должны использоваться в XHTML.</p>
<p>Теги XHTML могут иметь атрибуты. Атрибуты каждого тега перечислены в описании тега. Здесь представлены базовые атрибуты и атрибуты языка, которые являются стандартными для всех тегов (с небольшими исключениями).</p>
<p>Недействительны в элементах <strong>base, head, html, meta, param, script, style</strong> и <strong>title</strong>. </p>
<empty-line/>
<table>
<tr>
<th>Атрибут</th>
<th>Значение</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>class</strong></td>
<td><strong>правило_класса</strong> или <strong>правило_стиля</strong></td>
<td>Класс элемента</td>
</tr>
<tr>
<td><strong>id</strong></td>
<td><strong>имя_id</strong></td>
<td>Уникальный id элемента</td>
</tr>
<tr>
<td><strong>style</strong></td>
<td><strong>определение_стиля</strong></td>
<td>Встроенное определение стиля</td>
</tr>
<tr>
<td><strong>title</strong></td>
<td><strong>текст_подсказки</strong></td>
<td>Текст для вывода подсказки</td>
</tr>
</table>
<empty-line/>
<p>Недействительны в элементах <strong>base, br, frame, frameset, hr, iframe, param</strong>, и <strong>script</strong>.</p>
<empty-line/>
<table>
<tr>
<th>Атрибут</th>
<th>Значение</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>dir</strong></td>
<td><strong>ltr | rtl</strong></td>
<td>Задает направление текста</td>
</tr>
<tr>
<td><strong>lang</strong></td>
<td><strong>код_языка</strong></td>
<td>Задает код языка</td>
</tr>
</table>
<empty-line/>
<table>
<tr>
<th>Атрибут</th>
<th>Значение</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>accesskey</strong></td>
<td>символ</td>
<td>Задает клавиатурное сокращение для доступа к элементу</td>
</tr>
<tr>
<td><strong>tabindex</strong></td>
<td>число</td>
<td>Задает порядок элемента при переходе по клавише табуляции</td>
</tr>
</table>
<empty-line/>
<p>Новым в HTML 4.0 была возможность для событий HTML запускать в браузере действия, такие как запуск сценария JavaScript, когда пользователь щелкал на элементе HTML. Ниже представлен список атрибутов, которые можно вставлять в теги HTML для определения действий событий.</p>
<p>Более подробно об использовании этих событий в программировании можно узнать в руководстве по JavaScript и руководстве по DHTML.</p>
<p>Действительны только в элементах <strong>body</strong> и <strong>frameset</strong></p>
<empty-line/>
<table>
<tr>
<th>Атрибут</th>
<th>Значение</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>onload</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется при загрузке документа</td>
</tr>
<tr>
<td><strong>onunload</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется при выгрузке документа</td>
</tr>
</table>
<empty-line/>
<p>Действительны только в элементах форм.</p>
<empty-line/>
<table>
<tr>
<th>Атрибут</th>
<th>Значение</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>onchange</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется при изменении элемента</td>
</tr>
<tr>
<td><strong>onsubmit</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется при отправке формы</td>
</tr>
<tr>
<td><strong>onreset</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется при сбросе формы</td>
</tr>
<tr>
<td><strong>onselect</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется при выборе элемента</td>
</tr>
<tr>
<td><strong>onblur</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется, когда элемент теряет фокус</td>
</tr>
<tr>
<td><strong>onfocus</strong></td>
<td>сценарий</td>
<td>Сценарий, который выполняется, когда элемент получает фокус</td>
</tr>
</table>
<empty-line/>
<p>Недействительны в элементах <strong>base, bdo, br, frame, frameset, head, html, iframe, meta, param, script, style</strong> и <strong>title</strong>.</p>
<empty-line/>
<table>
<tr>
<th>Атрибут</th>
<th>Значение</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>onkeydown</strong></td>
<td>сценарий</td>
<td>Действие после нажатия клавиши</td>
</tr>
<tr>
<td><strong>onkeypress</strong></td>
<td>сценарий</td>
<td>Действие после нажатия и отпускания клавиши</td>
</tr>
<tr>
<td><strong>onkeyup</strong></td>
<td>сценарий</td>
<td>Действие после отпускания клавиши</td>
</tr>
</table>
<empty-line/>
<p>Недействительны в элементах <strong>base, bdo, br, frame, frameset, head, html, iframe, meta, param, script, style</strong> и <strong>title</strong>.</p>
<empty-line/>
<table>
<tr>
<th>Атрибут</th>
<th>Значение</th>
<th>Описание</th>
</tr>
<tr>
<td><strong>onclick</strong></td>
<td>сценарий</td>
<td>Что делать при щелчке мыши</td>
</tr>
<tr>
<td><strong>ondblclick</strong></td>
<td>сценарий</td>
<td>Что делать при двойном щелчке мыши</td>
</tr>
<tr>
<td><strong>onmousedown</strong></td>
<td>сценарий</td>
<td>Что делать при нажатии кнопки мыши</td>
</tr>
<tr>
<td><strong>onmousemove</strong></td>
<td>сценарий</td>
<td>Что делать при перемещении указателя мыши</td>
</tr>
<tr>
<td><strong>onmouseover</strong></td>
<td>сценарий</td>
<td>Что делать при перемещении указателя мыши над элементом</td>
</tr>
<tr>
<td><strong>onmouseout</strong></td>
<td>сценарий</td>
<td>Что делать при смещении указателя мыши с элемента</td>
</tr>
<tr>
<td><strong>onmouseup</strong></td>
<td>сценарий</td>
<td>Что делать при отпукании нажатой кнопки мыши</td>
</tr>
</table>
<empty-line/>
<p>В данном руководстве было показано, как создавать более строгие и четкие страницы HTML.</p>
<p>Главное заключается в том, что все элементы XHTML должны быть правильно вложены, документы XHTML должны быть синтаксически правильными, все имена тегов должны быть записаны в нижнем регистре, и все элементы XHTML должны быть закрыты.</p>
<p>Важно также то, что все документы XHTML должны иметь объявление DOCTYPE, и что должны присутствовать элементы <strong>html, head, title</strong>, и <strong>body</strong>.</p>
<p>Дополнительную информацию о XHTML можно найти в любом справочном руководстве по XHTML.</p>
<p>Следующий шаг состоит в изучении CSS и JavaScript.</p>
<p>CSS используется для управления стилем и компоновкой Web-страниц.</p>
<p>При использовании CSS все форматирование можно вынести из документа HTML и сохранить в отдельном файле.</p>
<p>CSS предоставляет полный контроль над компоновкой, не создавая путаницу в содержимом документа.</p>
<p>Познакомиться с каскадными таблицами стилей можно в любом руководстве по CSS.</p>
<p>Язык JavaScript может сделать Web-сайт более динамичным.</p>
<p>Статичный Web-сайт вполне подходит для вывода простого содержимого, но динамичный Web-сайт может реагировать на события и позволяет организовать взаимодействие с пользователем.</p>
<p>JavaScript является наиболее популярным языком сценариев в Интернет, и он работает со всеми основными браузерами.</p>
<p>Более подробно познакомиться с JavaScript можно с помощью любого руководства по JavaScript.</p>
</section>
</body>
<binary content-type="image/png" id="img1.png">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</binary>
<binary content-type="image/png" id="logo.png">iVBORw0KGgoAAAANSUhEUgAAAR0AAAA0BAMAAABFkPECAAAAMFBMVEUEAgT8mgScmpz8zpz8/vz8mmT8/sxkZmTMzsw0MjT8zmT8mjT8zsysOLGAADd8AH6mpM0XAAAAEHRSTlP/////AP//////////////+zjD8QAAAAlwSFlzAAAATwAAAE8BY4r91wAACY1JREFUeNrNmb9PG8sWx0cWkr1lxA0FpLCilYDSskkRp0h2D+s1pkE4r4DXIDYurlNYV5ZiOmStFLtbIUvslijmFrhCBgpME+Gb4iZ/1Puemf1lE+57zVNY2cN6dubMZ86vmVkEPanrrXgSGI3i+ZdXjSfC07g/v3z2bGXyxfn1PNb9+QQs13vFN42nYK/vk8lFseE8Gf+xnqY/p3l6PfVx5ScqbC7iB2HRQw9Z7UbN0S5saie9yF7t9Ob7xgJm1PPjx32xWDx///58MplcM08lCLpB8EcQdILAD4LA8wMhRLuP21MjrBXCkxVZIjT3K8GJbOsfBf56cLLuCe2EjlDiCS6X+kJkcLsWSuwEnvD0PG4zszi/I67S1xV4DKH1PKHj0xJtDyiDFhdVFGJNCBe1XNE+RgEeA88MbqjnxQCfY5HjJ8LNo8gZfDsgiMnYqPNYglBi29xglucQOpnheQ4e28tSS1BLg0Sdey/kheZhTM0TA0+jvHCPRZYHFkKDEE+0bc+VtfqxaFcZHU31tyhzNt/mKtBnltC3JXpCzTBQs8o88OfGYbH4+v3+ZCJVVQ95NOY5Fq6WF+vg0fsLhsj1ISjk0fuD/KrwmScPnrhW6BUxqDAsg1VytpepilxV+BUIzVJe62XzWh48Lop1cZJ9PCk2GvfFi134s8f9FE8vx1+MZYDHryY8qFg3xGAdHY/FwM6medoVVpFeBWcGPAYbUAcy61brDvKasQAxlcEpmn5KZ8LX77+oJDgbX6FqNYzUg5e4Psbq+QZPM+FZ8/8ATx+xg/nbGdSiK/NUEx699wd4bMEToiMltNvGXH2IWRt0IK8fD7y9Lz1mMtl748zzwOro2suLrs5DQ9xaJ+LpKZ5OZw08FfBURMbIgaen9JOXPH3hgqf7WfGAhNbBA7ldFzwd8HQ60tVS+tmIgwtM39I8VeZhx+vy0F0Q+C8ljy5rudJ/yTwG5xahVRaIg0XyeJInn4Xe9NWutJcPjVPV9TQj5FnLa7a/Jj0sbZvtchJZK5O94reI5zji6cFmLjQSZHqGWDjmYFc8Qa7ngsd2OcC0/iDmQTwzj5cDT5C1pT+3OS9UXC/bRyph3+whvvweNDiwQ90cbly/4oDfnwn3yZ7kybRkaH7yYHYw8FgZ5Bm/lQ1rj2WggkcKa4l8G20+tZhnVWOeQOjgAQZ44IWyNXjynuYyD082x543CBXDWWdll/3mfoZoRekniOJrhicrfIr8Oc2TR66N4+volHmgJObRwJNlD0JrG/YKWj/nIWWoCavI+vtynkfLzPP0spyHcRvx9E4SnmMh2yge77Pk8dh/OkfgAZqh0p4nkHtCHq07wxMCPZMqSjn2suSBO87xuJ+Yx6eYx11NeOD9CY8m8w8yDsdXn3l4KiFPLuGhk4iH887UOlMA0ovo4yjkWVQ87Qc8n9lebornc8Jj8LIR8WSifIjo0Svg0XSyI55BwuO+DHlMNa61EyKMZfYJHTvkcR/wdDFqjlI8lYTH5vCJeHzFo1Ki4cKfKeHRUzzdSD/SODdkRkZ6LlVE9wy4pPyHHvDw6H6ah2IeOGom4WkrHpWtsDlSPHKZknJjHop4DqTjlhKgFaUien0p9xvp9SvhMbqz+kH8Rjx6K0fz65eteGydeSjkyc7wVFzFYyqtOPR7ss1QKtreqD/KU5nnqUQ8hp7/GU+GeQzFw+sFuXP6+RzFl/KcMdGHJM7Hzsx6+pCnP+c/1KeY53jwGE/FVTxob7dbszyrEU9TMQzjqE+p6FGe1Xme9Yin0q4+ytNXPHk2XXtOP58iHjPUiTMDFAbaYzyn8zynCc+x/oBH+jNWEZI82CJRRZ/hIcrE+fAsSjYUpSEF+Crmac3zGJnZ+NKNTMRTHeRdmt8fVsUC8wSKp4qA78/4DxJGLuaphQA3cOGdNJA8L9s/4enkM7P6QQU2PlJcP+c94MEWDkh+PyvzD+f2Nc+N4ouXHQhIeLaj8UuURD2uPyni8QRPgc2uvoL35DkZKbxzlxWkanCWUbvo9H6e17q3fP6IUg+vrXLT4IZfXn3i9asQHydib8J1p/wHq2FPnmw6nvBxSMnxmsibnyxnNkwU+yvJkxcyq1Xk6o1DAx60eG+aUScheZypCJk6UaMZUmib10FbnYJaItzO19IIH+K1S/EY8jy4pk5++OHbfKYb9INTKF49OEKFT+t80gOKh1nasjY8D+KkeKoTNzqpRG3EqerbjiW20eI03I7FRirxK4UoQf7T+d19vKLn/vdj+MOT8YzEQtqFZdSzL/269wmbsdNIK42UL/86nsRgz/7FP3fufsn7luLwgcGUoax/eP+zzSZt/FTetvPz10kWt8etowre8XHhxNIc1fRwGgnYSrLO8tz51Bxb11Qu1epwLE5Qe5Mp7Z+Prcm0XCcTy/A+laebN+YdP3L4Vwm/xjRy5F0TfUb7+075YozfY2qWalf04eIWTrI/pi3Z5RztrdtwEHWl0uDdLM/2i61Far76PqTXO5MSlZ3aDZVp2boc7gxpEynrnArO5tX3JX50RaNGwTFvDvELWp9ayxcQUiqbpcKbItXGdXr3qlmnWyoMacO8oRFxFypaS5uLdOCclaJxv6bWidIsz3gXs9odDc2lZnERoqxFKn+4sXZXNob0V9lRPLu7SzSm7UU6+zJyzNsN8HyB3qhwJY8LGGBUIgvh+263PATI1m/0b/MKXSBtRJb1AoMc/FWIh95Kv/Vx0jzWCmt5WhtuXjWnE0gAUnmXrPqkNqQRJEie5x+XIJmuIfzAMa9M8Px9831KBzGPM4UVpvSutFkHyPaShT8WpMGycJ6VKXjG7xJVpN+MvZjRzyK6NJ3a0Fxslm4xIvNAQr0BnrtCPbTX9hItK+HMs832ugbP3nXMQ445ulI8L8j8zRyCB260KHl4kINSiqc5t9FI9HNHSj9U3j8f0tnUlL5BdQIijMg8tFkHwZkjPeKAQp7Jd8esF6YRjzltWsuShyZUq2+WoCYpjXnY2u+cFE+yjt7Ovm8xF60VuB8r/gzuv3U7mtKlQ9t3sEWtbj6ny4vLUu0GTr95i5i6hFPWlsxF2jm/K5S+lg5Y2TsOne1NEKeXpa91xEPz9j1tXqFLJA2DPKdCSVlXXdHOZ3cu3q0GskfDsUDJX/o4VekHyQSV/PTH4ZW8CR81wupvuGsQ13P7xg8lR0n6KHvHXSg1SHTVHtjqf8/P3/4PyVoa7Hb6dN7Pn0V7+CfCU1v580n9P84qPd3/DyY8/wFDJefa5Rn8CQAAAABJRU5ErkJggg==</binary>
<binary content-type="image/png" id="scope1.png">iVBORw0KGgoAAAANSUhEUgAAAXQAAABsCAMAAABNT7kjAAADAFBMVEUEAgR/goTExMdEQ0Tk4+Sjo6QwQpwEF4zT09Xz9Pl8foScpNJ2g8IbMZRhYWPq7PQkIyS+xOK8vsREVarP0+tXZbJndLqTlJaJlMnj5fSzsrYPJJD8/vxub3QxMjRUVFQoO5wTEhSutNqMio2srrIsLjScnKE8PkMcHiTMzc5MTVI6TKTY3NyAjMTHzeTa3elebLRxfLySnMwMDgyjq9RLXKy0vNwkNpy8urxkZmQUKpRcWlwHHox0dnTh5Ow0RqQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACY8PhlAAABAHRSTlP/////////////////////////////////////AP//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////vwpYTwAAAAlwSFlzAAAATwAAAE8BY4r91wAAD+JJREFUeNrtXYliqjoQDW5tBIw+EUGpWrWLdV8QS63+/1+9mQAKqC1Ya3vvZUB2SHJmMtkOSIygrBqEvDEjke8UEtylxZXB3tMJLtcEfcXx7hhG7zUNywwsmbHqvuMO66RfBwlilwedzV+76FzYfWfV6LB5Z9VMG5057hjN5qozTzzP5UE3es170uwZ1VfDGKxwaRQHnSbsFAdF2Hl9TCC7POiI++s963S4m8FlesVXZEVQOglkFwf9kYPaWAl5WFU772jpPVyx+14DdhKf/g2g9+Y9QPaeDeYro5Me3MOyCD69x17fjWIHnMwqgezy7uXxPp2eg+PuFkm65y47zSJ5ZUYvTe4T7/I9Pn21CtdQOkKC03cXpAfSSez7+qCvEkd+fdAT+SbQWfWtQaJKo1nNJNB9GfRXEldeE+y+BnoqTUgzm4p6D+1lXwhJpxL0vgB6l5BiXAR7RUJqCXxng14j5I7GvpG9E9JN8DsT9MycBBo/h/if0IhA7pPi9EzQm6R5FGaKS/oR8E3ylgB4FugZQgZHIffv0tBRZz0gZG/qVFFoAmdE0KtgrvSDyZmdrfC5JqnuMF+YFSWBMyLobyRLOZy72QWZBlb7yTsGy8edf6Ht/lrVEzgjgl4ktyFQaRBqKqRgWU03awf4D0jRw7wsm6UEzaigz0mGhmRnylwEsqK02shW57fhCxlxGrR0WbYTzGOATkgYSuE/SrPd/2q1bq1LaSPdgGUafu9C+ErqgA52bpcXOnOEMk9z1HFWhm9hJIWtAzoLIZltZLrFzHsahdIaTdcYRc100ydAb7fW9Vaun9vmtv1c35MyiAlSMScgqjqdSpI01LSZKC7a7eWyBDIaKYoy3uigMBq5ffB3WDpzJ2dB2V2h+B9l3lGGVo4X1dK7i9wNF/TJzWey5tPNer2uo9i2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</binary>
<binary content-type="image/png" id="scope2.png">iVBORw0KGgoAAAANSUhEUgAAATwAAAC+CAMAAACf1ENTAAADAFBMVEUEAgSCgoTExMhDQ0Tk5OSjo6QsQpwEGIzz9PiYpNDS09V4hMJ8foRhYWPq7PQkIyQcL5SysrZXY7GTlZbO0+xndLrAxOO8vsRvcHRUVFTi5fT8/vyHlMdEVaoOJI80MjQTEhSus9wnPJyMioxMTVGsrbJlZ2UsLjScm54cHiTMzc08PkM5TaSkq9Ta3dyBjMRdbbTb3eZxfLzHy+SPnMwMDgxMW6y2vNy8urxcWlwkNpwUKpQHHox0dnTh5Ow0RqQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB7V0p+AAABAHRSTlP///////////////////////////////////8A////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////QFpgwwAAAAlwSFlzAAAATwAAAE8BY4r91wAADyhJREFUeNrtnQtDqjwYx4fg607hkLBSqKy8JZYdKgqPRd//W70bqGxcjFsCykTkpid+Z4xn4/88D9AKLhNQ2TIBRcMr/A/I8KfX8Gp4NbwaXg2vYHjWAIAlquGlgQclS0NffA0vDTzL4TbUNH3C4/kCz5Fmjb/IChryk0UNLxoeup2MyUULzaE1GCI87/Pa0FnR+n1raKIaXnSbp/dvQV/XlAmudtYDnmvSYtjHK9JCIp2ShxrezrutPrmFQ44scfhi1XjL+QCW0y8a1vAi4T04cAYWJzorX6Tm6eQD3eoDvFK3eTvg6bc6JnSLFqalDfnFLZ5L2vBWR5MvTRrii9eq4UVftg+3PH+LG7axBHh9PR/2JTBBms6D22Fd83a2eZblv6O6DWBt56Xqng2HNbzU8CyrhlcPDPwWPKT0B7EHwQd9RajhbUvyxxmTGt7aupsD0G/qsb+oN0cA8I0aHi5jAKZJSegSAHINT5MB6MHEX4Y9AMZHD08wwZCw8/PbxdPZx4Fb4djh9UGfZkJzhM6L2kbthOSbyyOHJwCwcFn4MUEfUvoAZ30BgHDc8BSwhFqslzvRryVQjhveEjwwfLZX63YD3F6+1KXs7Hso7LotCTwJnLD1C26rGNxUN4HHBcL1vs0uDS6AdNzwTCDAYKEg4kkeyLIcchQq7BxKAg+AECrwkoNQ4ASZFB1yHAwvNbxQLAMF8pzFz3l+jpfmwFRqeGHwEK5kEEH36kVkwi9d6o22GzBJXbp096yPdBZqeIBQWGMS1oDwh4jbQp374jhRdrZxHIJrsNvPus0DaF2gMzlvhITZVEQnIi7cWFfwhp5IHbNZqOGhsDISF6a1XjbMMRrP9JCjCoSXq6B6kh2e7c2HU4R5LdbbLQnMHuhjnLpZLDyQezVKZecZDhLbz2/33JkZwDxu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</binary>
</FictionBook>